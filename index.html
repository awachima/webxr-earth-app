<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebXR Earth Controls (stable)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <!-- Troika / A-Frame troika-text -->
  <script src="https://cdn.jsdelivr.net/npm/troika-worker-utils@0.47.2/dist/troika-worker-utils.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/troika-three-utils@0.47.2/dist/troika-three-utils.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/troika-three-text@0.47.2/dist/troika-three-text.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-troika-text@0.9.0/dist/aframe-troika-text.min.js"></script>

  <style>
    @font-face{
      font-family:"NotoSansJPLocal";
      src:url("static/NotoSansJP-Regular.ttf") format("truetype");
      font-weight:400; font-style:normal; font-display:swap;
    }
    body{ margin:0; background:#eee; }
  </style>
</head>
<body>

<script>
/* ===== 共通ユーティリティ ===== */
const FONT_URL = 'static/NotoSansJP-Regular.ttf';
window.__panelOpen = false;

function refreshAllRaycasters(){
  ['#mouseCursor', '#right-hand'].forEach(function(sel){
    var el=document.querySelector(sel);
    var rc = el && el.components && el.components.raycaster;
    if(rc && rc.refreshObjects) rc.refreshObjects();
  });
}
function setRaycasterTargets(uiOnly){
  var objs = uiOnly ? '.ui' : '.collidable, .ui';
  ['#mouseCursor', '#right-hand'].forEach(function(sel){
    var el=document.querySelector(sel);
    if(el) el.setAttribute('raycaster','objects',objs);
  });
}

/* ----- テキストを確実に前面化（Troikaが再同期しても耐性） ----- */
AFRAME.registerComponent('force-front',{
  schema:{ order:{type:'number',default:100010}, frames:{type:'int',default:12} },
  init:function(){ this._applied=0; },
  tick:function(){
    if(this._applied >= this.data.frames) return;
    const mesh = this.el.getObject3D('text') || this.el.getObject3D('mesh');
    if(!mesh) return;
    mesh.renderOrder = this.data.order;
    if(mesh.material){
      mesh.material.transparent = true;
      mesh.material.depthWrite  = false;
      mesh.material.depthTest   = true;
      mesh.material.depthFunc   = THREE.AlwaysDepth;
      mesh.material.side        = THREE.DoubleSide;
    }
    this._applied++;
  }
});

/* ----- パネルを“表示時の位置”にワールド固定（ワールド水平垂直） ----- */
AFRAME.registerComponent('panel-world-lock',{
  schema:{
    baseDist:{type:'number',default:0.5},
    baseScale:{type:'number',default:0.5},
    margin:{type:'number',default:0.03},
    minDist:{type:'number',default:0.08},
    faceCamera:{type:'boolean',default:false},
    worldYaw:{type:'number',default:0},
    yOffset:{type:'number',default:0.20} // ← 相対高さ（m）
  },
  init:function(){
    this.cam = document.querySelector('#camera');
    this.earth = document.querySelector('#earth');
    this._camPos   = new THREE.Vector3();
    this._earthPos = new THREE.Vector3();
    this._fwd      = new THREE.Vector3();
    this._placed = false;
  },
  tick:function(){
    if(!this._placed) this.placeOnce();
    if(this.data.faceCamera && this.cam){
      this.cam.object3D.getWorldPosition(this._camPos);
      this.el.object3D.lookAt(this._camPos);
      const e=this.el.object3D.rotation;
      this.el.object3D.rotation.set(0,e.y,0);
    }
  },
  placeOnce:function(){
    if(this._placed || !this.cam) return;
    this._placed = true;

    // カメラ位置と前方
    this.cam.object3D.getWorldPosition(this._camPos);
    this._fwd.set(0,0,-1).applyQuaternion(this.cam.object3D.quaternion).normalize();

    // 希望距離
    let dist = this.data.baseDist;

    // 地球前面より必ず手前へ
    if(this.earth){
      this.earth.object3D.getWorldPosition(this._earthPos);
      const s = this.earth.object3D.scale.x || 1;
      const R = (this.earth.getAttribute('geometry')?.radius || 1) * s;
      const along = this._earthPos.clone().sub(this._camPos).dot(this._fwd);
      const nearAlong = along - R;
      if (nearAlong <= dist + this.data.margin){
        dist = Math.max(this.data.minDist, nearAlong - this.data.margin);
      }
    }
    dist = Math.max(this.data.minDist, dist);

    // ワールド座標で固定配置（Yに相対オフセットを足す）
    const worldPos = this._camPos.clone().add(this._fwd.clone().multiplyScalar(dist));
    worldPos.y += this.data.yOffset;
    this.el.object3D.position.copy(worldPos);

    // 見かけスケール維持
    const scl = this.data.baseScale * (dist / this.data.baseDist);
    this.el.object3D.scale.set(scl, scl, scl);

    // ワールド水平垂直（Yアップ、ロール/ピッチ0、ヨーは指定角）
    const yawRad = THREE.MathUtils.degToRad(this.data.worldYaw);
    this.el.object3D.rotation.set(0, yawRad, 0);
  }
});

/* ===== 新デザインの3Dパネル ===== */
const PANEL_BASE = { DIST: 0.5, SCALE: 0.5, LINES: 12 };

function safeText(s){ return String(s==null?'':s).replace(/;/g,'；'); }

function pm_btn(x,y,w,h,label,onClick){
  var e=document.createElement('a-entity');
  e.classList.add('ui','collidable');
  e.setAttribute('geometry',`primitive:plane;width:${w};height:${h}`);
  e.setAttribute('material','shader:flat; color:#2b2f36; opacity:0.95; transparent:true; side:double; depthTest:false');
  e.setAttribute('position',`${x} ${y} 0.01`);
  var t=document.createElement('a-entity'); t.classList.add('ui');
  t.setAttribute('troika-text',[
    `value:${safeText(label)}`,
    `font:${FONT_URL}`,
    'fontSize:0.04',
    'color:#fff',
    'anchor:center'
  ].join('; '));
  t.setAttribute('position','0 0 0.001');
  t.setAttribute('force-front','order:100012');
  e.appendChild(t);
  e.addEventListener('click',onClick);
  e.addEventListener('mouseenter',()=>e.setAttribute('material','color','#3a4049'));
  e.addEventListener('mouseleave',()=>e.setAttribute('material','color','#2b2f36'));
  return e;
}

function pm_liftRenderOrder(root){
  root.object3D.renderOrder = 9999;
  root.object3D.traverse(function(obj){
    if(obj.material){
      obj.material.depthTest=false;
      obj.material.transparent=true;
    }
  });
}

/* 折り返し高さを計測して自動レイアウト */
function pm_layoutWrappedList(panel){
  var items = Array.from(panel.querySelectorAll('.list-item'));
  if(!items.length) return;

  var heights = new Array(items.length).fill(0);
  var remaining = items.length;

  function placeAll(){
    var y = 0.48;        // タイトル直下
    var gap = 0.02;      // 行間
    items.forEach(function(el,i){
      el.setAttribute('position', `${-0.45} ${y} 0.03`); // テキストは面より前へ
      y -= (Math.max(heights[i], 0.035) + gap);
    });
  }

  items.forEach(function(el,i){
    function tryMeasure(){
      var mesh = el.getObject3D('text') || el.getObject3D('mesh');
      if(!mesh){ requestAnimationFrame(tryMeasure); return; }
      var afterSync=function(){
        if(!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
        var bb = mesh.geometry.boundingBox;
        heights[i] = Math.max((bb.max.y - bb.min.y), mesh.fontSize || 0.035);
        if(--remaining===0) placeAll();
      };
      if(typeof mesh.sync === 'function'){ mesh.sync(afterSync); }
      else { requestAnimationFrame(afterSync); }
    }
    tryMeasure();
  });
}

function pm_renderList(panel, list, from){
  var root=panel.querySelector('.list-root'); root.innerHTML='';
  var end=Math.min(from+PANEL_BASE.LINES, list.length);

  for(var i=from;i<end;i++){
    var item=document.createElement('a-entity');
    item.classList.add('ui','list-item');
    item.setAttribute('troika-text',[
      `value:${safeText(list[i].title)}`,
      `font:${FONT_URL}`,
      'fontSize:0.035',
      'lineHeight:1.25',
      'color:#fff',
      'maxWidth:0.9',
      'anchor:left',
      'baseline:top',
      'outlineWidth:0.004',
      'outlineColor:#000'
    ].join('; '));
    item.setAttribute('force-front','order:100011');
    (function(url){
      item.addEventListener('click',function(){ try{ if(url) window.open(url,'_blank'); }catch(_){ } });
    })(list[i].url);
    root.appendChild(item);
  }
  pm_layoutWrappedList(panel);
}

/* 開閉API（既存呼び出し互換） */
function openPanel(locations){ openVrPanel(locations); }
function closePanel(){ closeVrPanel(); }

/* ワールド固定の3Dパネル生成（カメラ追従なし） */
function openVrPanel(locations){
  closeVrPanel();
  var scene = document.querySelector('a-scene');
  var panel=document.createElement('a-entity');
  panel.id='vrPanel';
  panel.classList.add('ui','collidable');

  // ひとまず基準値（実配置は panel-world-lock が初回tickで決定）
  panel.setAttribute('position', `0 0 -${PANEL_BASE.DIST}`);
  panel.setAttribute('rotation','0 0 0');
  panel.setAttribute('scale', `${PANEL_BASE.SCALE} ${PANEL_BASE.SCALE} ${PANEL_BASE.SCALE}`);
  // カメラ角度に合わせず、ワールド水平垂直へ固定 + 高さオフセット（相対）
  panel.setAttribute(
    'panel-world-lock',
    'base-dist:0.5; base-scale:0.5; margin:0.03; min-dist:0.08; face-camera:false; world-yaw:0; y-offset:-0.07'
  );

  // 枠・背景
  var border=document.createElement('a-entity'); border.classList.add('ui');
  border.setAttribute('geometry','primitive:plane;width:1.12;height:1.22');
  border.setAttribute('material','shader:flat; color:#ffffff; opacity:0.12; transparent:true; side:double; depthTest:false');
  panel.appendChild(border);

  var bg=document.createElement('a-entity'); bg.classList.add('ui');
  bg.setAttribute('geometry','primitive:plane;width:1.1;height:1.2');
  bg.setAttribute('material','shader:flat; color:#202428; opacity:0.98; transparent:true; side:double; depthTest:false');
  panel.appendChild(bg);

  // タイトル
  var head = locations.length ? (String(locations[0].title).split(/\s+/)[0] + ' など（' + locations.length + '件）') : 'Places';
  var title=document.createElement('a-entity'); title.classList.add('ui');
  title.setAttribute('troika-text',[
    `value:${safeText(head)}`,
    `font:${FONT_URL}`,
    'fontSize:0.05',
    'color:#CCFF00',
    'maxWidth:1.0',
    'anchor:left',
    'baseline:top',
    'outlineWidth:0.004',
    'outlineColor:#000',
    'lineHeight:1.1'
  ].join('; '));
  title.setAttribute('position','-0.45 0.55 0.03');
  title.setAttribute('force-front','order:100012');
  panel.appendChild(title);

  // リスト
  var listRoot=document.createElement('a-entity');
  listRoot.classList.add('ui','list-root');
  panel.appendChild(listRoot);

  // ボタン（× / ▲ / ▼）
  var scrollIndex=0;
  function rerender(){ pm_renderList(panel, locations, scrollIndex); }

  panel.appendChild(pm_btn( 0.50, 0.55, 0.12, 0.12, '×', function(){ closeVrPanel(); }));
  panel.appendChild(pm_btn( 0.45, 0.40, 0.12, 0.12, '▲', function(){
    if(scrollIndex>0){ scrollIndex--; rerender(); }
  }));
  panel.appendChild(pm_btn( 0.45,-0.40, 0.12, 0.12, '▼', function(){
    if(scrollIndex < Math.max(0, locations.length - PANEL_BASE.LINES)){ scrollIndex++; rerender(); }
  }));

  pm_liftRenderOrder(panel);
  scene.appendChild(panel);

  rerender();

  window.__panelOpen = true;
  setRaycasterTargets(true); refreshAllRaycasters();
  document.querySelector('a-scene').emit('panel-opened');
}
function closeVrPanel(){
  var p = document.getElementById('vrPanel');
  if (p && p.parentNode) p.parentNode.removeChild(p);
  window.__panelOpen = false;
  document.querySelector('a-scene').emit('panel-closed');
  setRaycasterTargets(false); refreshAllRaycasters();
}
</script>

<script>
/* ============ Earth Controls（VR安定・非VR互換） ============ */
AFRAME.registerComponent('earth-controls',{
  schema:{
    rotationSpeed:{type:'number',default:2.0},
    joystickRotationSpeed:{type:'number',default:1.0},
    scaleSpeed:{type:'number',default:0.01},
    mouseRotationSpeed:{type:'number',default:0.2},
    wheelScaleSpeed:{type:'number',default:0.0005}
  },
  init:function(){
    this.minScale=1.0; this.maxScale=3.0;
    this.currentXRotation=0;
    this.keys={};
    this.stickInput={ left:{x:0,y:0}, right:{x:0,y:0} };
    this.isDragging=false;
    this.previousMousePosition={x:0,y:0};
    this.cameraEl=document.querySelector('#camera');
    
    this.uiState = { rotUp: false, rotDown: false, rotLeft: false, rotRight: false, zoomIn: false, zoomOut: false };

    var self=this;
    window.addEventListener('keydown',function(e){ self.keys[e.key]=true; });
    window.addEventListener('keyup',function(e){ self.keys[e.key]=false; });

    this.el.sceneEl.addEventListener('loaded', function(){
      var cvs=self.el.sceneEl.canvas;
      cvs.addEventListener('mousedown',function(e){ self.onMouseDown(e); });
      window.addEventListener('mousemove',function(e){ self.onMouseMove(e); });
      window.addEventListener('mouseup',function(){ self.onMouseUp(); });
      if (!AFRAME.utils.device.checkHeadsetConnected()) {
        cvs.addEventListener('wheel',function(e){ self.onWheelCanvas(e); },{passive:true});
      }
      
      self.setupUIListeners();
    });
    
    this._bindThumbsticks = function(){
      var L=document.querySelector('#left-hand');
      var R=document.querySelector('#right-hand');
      if(L && !L._thumbBound){
        L.addEventListener('thumbstickmoved', function(e){ self.stickInput.left={x:e.detail.x,y:e.detail.y}; });
        L.addEventListener('axismove', function(e){
          var a=(e.detail && e.detail.axis) ? e.detail.axis : [];
          if (self.stickInput.left.x === 0 && self.stickInput.left.y === 0) {
            self.stickInput.left={x:a[0]||0, y:a[1]||0};
          }
        });
        L._thumbBound=true;
      }
      if(R && !R._thumbBound){
        R.addEventListener('thumbstickmoved', function(e){ self.stickInput.right={x:e.detail.x,y:e.detail.y}; });
        R.addEventListener('axismove', function(e){
          var a=(e.detail && e.detail.axis) ? e.detail.axis : [];
           if (self.stickInput.right.x === 0 && self.stickInput.right.y === 0) {
            var rx = (typeof a[2] === 'number') ? a[2] : (a[0]||0);
            var ry = (typeof a[3] === 'number') ? a[3] : (a[1]||0);
            self.stickInput.right={x:rx, y:ry};
          }
        });
        R._thumbBound=true;
      }
    };

    var leftHand = document.querySelector('#left-hand');
    var rightHand = document.querySelector('#right-hand');
    
    if(leftHand)  leftHand.addEventListener('controllerconnected', this._bindThumbsticks.bind(this));
    if(rightHand) rightHand.addEventListener('controllerconnected', this._bindThumbsticks.bind(this));
  },
  
  setupUIListeners: function() {
    var self = this;
    var states = [
      { id: '#btn-rot-up',    state: 'rotUp' },
      { id: '#btn-rot-down',  state: 'rotDown' },
      { id: '#btn-rot-left',  state: 'rotLeft' },
      { id: '#btn-rot-right', state: 'rotRight' },
      { id: '#btn-zoom-in',   state: 'zoomIn' },
      { id: '#btn-zoom-out',  state: 'zoomOut' }
    ];

    states.forEach(function(item) {
      var btn = document.querySelector(item.id);
      if (btn) {
        btn.addEventListener('mousedown', function() { self.uiState[item.state] = true; });
        btn.addEventListener('mouseup', function() { self.uiState[item.state] = false; });
        btn.addEventListener('mouseleave', function() { self.uiState[item.state] = false; });
      }
    });
  },

  onMouseDown:function(evt){
    if (evt.target.classList.contains('ui')) return;
    if(window.__panelOpen) return;
    this.isDragging=true;
    this.previousMousePosition={x:evt.clientX,y:evt.clientY};
    if(this.cameraEl) this.cameraEl.setAttribute('look-controls','enabled',false);
  },
  onMouseMove:function(evt){
    if(!this.isDragging || window.__panelOpen) return;
    var dx=evt.clientX-this.previousMousePosition.x;
    var dy=evt.clientY-this.previousMousePosition.y;
    this.el.object3D.rotation.y += dx*(Math.PI/180)*this.data.mouseRotationSpeed;
    this.currentXRotation += dy*this.data.mouseRotationSpeed;
    this.previousMousePosition={x:evt.clientX,y:evt.clientY};
  },
  onMouseUp:function(){ this.isDragging=false; },
  onWheelCanvas:function(evt){
    if(window.__panelOpen) return;
    var s=this.el.object3D.scale.x;
    s += evt.deltaY*-1*this.data.wheelScaleSpeed;
    var ns=Math.max(this.minScale,Math.min(this.maxScale,s));
    this.el.object3D.scale.set(ns,ns,ns);
  },
  getNonVrSticks:function(){
    var pads = (navigator.getGamepads && navigator.getGamepads()) ? navigator.getGamepads() : [];
    var p = null;
    for (var i=0;i<pads.length;i++){ if(pads[i] && pads[i].connected){ p=pads[i]; break; } }
    if(!p) return null;
    var ax = p.axes || [];
    return { left:{x:ax[0]||0, y:ax[1]||0}, right:{x:ax[2]||0, y:ax[3]||0} };
  },
  tick: function() {
    if (window.__panelOpen) return;

    var rotY_k = (this.keys['ArrowLeft'] ? -1 : 0) + (this.keys['ArrowRight'] ? 1 : 0);
    var rotX_k = (this.keys['ArrowUp'] ? -1 : 0) + (this.keys['ArrowDown'] ? 1 : 0);
    var scale_k = (this.keys['w'] || this.keys['W'] ? 1 : 0) + (this.keys['s'] || this.keys['S'] ? -1 : 0);
    
    var rotY_ui = (this.uiState.rotRight ? 1 : 0) + (this.uiState.rotLeft ? -1 : 0);
    var rotX_ui = (this.uiState.rotDown ? 1 : 0) + (this.uiState.rotUp ? -1 : 0);
    var scale_ui = (this.uiState.zoomIn ? 1 : 0) + (this.uiState.zoomOut ? -1 : 0);

    var stickRotX = this.stickInput.right.y;
    var stickRotY = this.stickInput.right.x;
    var stickScale = this.stickInput.left.y;

    if (stickRotX === 0 && stickRotY === 0 && stickScale === 0) {
      var gp = this.getNonVrSticks();
      if (gp) {
        stickRotX = gp.right.y; stickRotY = gp.right.x; stickScale = gp.left.y;
      }
    }
    
    var s = this.el.object3D.scale.x;
    // 正規化を min/maxScale 参照に
    var t = (s - this.minScale) / (this.maxScale - this.minScale);
    t = Math.max(0, Math.min(1, t));
    var mul = 1 - (t * (7 / 8));
    
    var finalRotY = (stickRotY !== 0 ? stickRotY * this.data.joystickRotationSpeed : (rotY_ui !== 0 ? rotY_ui * this.data.rotationSpeed : rotY_k * this.data.rotationSpeed)) * mul;
    var finalRotX = (stickRotX !== 0 ? stickRotX * this.data.joystickRotationSpeed : (rotX_ui !== 0 ? rotX_ui * this.data.rotationSpeed : rotX_k * this.data.rotationSpeed)) * mul;
    var finalScale = (stickScale !== 0 ? -stickScale : (scale_ui !== 0 ? scale_ui : scale_k)) * this.data.scaleSpeed;

    this.el.object3D.rotation.y += finalRotY * (Math.PI / 180);
    this.currentXRotation = Math.max(-80, Math.min(80, this.currentXRotation + finalRotX));
    this.el.object3D.rotation.x = this.currentXRotation * (Math.PI / 180);

    var ns = s + finalScale;
    ns = Math.max(this.minScale, Math.min(this.maxScale, ns));
    this.el.object3D.scale.set(ns, ns, ns);
  }
});

/* ============ hex-marker ============ */
AFRAME.registerComponent('hex-marker',{
  schema:{ count:{type:'number',default:1}, color:{type:'color',default:'yellow'},
           baseRadius:{type:'number',default:0.0075}, heightUnit:{type:'number',default:0.0001},
           fontUrl:{type:'string',default:FONT_URL} },
  init:function(){
    var d=this.data;
    this.height=0.01+(d.count*d.heightUnit);
    var geom=new THREE.CylinderGeometry(d.baseRadius*0.7,d.baseRadius,this.height,6);
    var mat =new THREE.MeshStandardMaterial({color:d.color,flatShading:true});
    this.el.setObject3D('mesh', new THREE.Mesh(geom,mat));

    try{
      var baseFontSize=d.baseRadius*0.7;
      var text=document.createElement('a-entity');
      text.setAttribute('troika-text',{
        value:String(d.count),
        font:d.fontUrl,
        fontSize:baseFontSize,
        color:'#111',
        outlineColor:'#fff',
        outlineWidth:0.0006,
        outlineBlur:0.00001,
        anchor:'center'
      });
      text.setAttribute('rotation','-90 0 0');
      text.setAttribute('position',{x:0,y:this.height/2+0.00012,z:0});
      this.el.appendChild(text);
      this.el.textEl=text;
    }catch(err){
      console.warn('Troika text disabled:', err);
    }
  }
});

/* ============ marker-placer ============ */
AFRAME.registerComponent('marker-placer',{
  // 最大/最小ズーム時の倍率をパラメータ化
  schema:{
    maxMarkerMultiplier:{type:'number',default:20},  // 最小ズーム時（地球が小さい時）
    minMarkerMultiplier:{type:'number',default:1}    // 最大ズーム時（地球が大きい時）
  },
  
  init:async function(){
    this.allLocations=[]; this.currentMarkers=[];
    this.cameraEl=document.querySelector('#camera');
    this.cameraPos=new THREE.Vector3();
    this.markerPos=new THREE.Vector3();
    this.earthPos =new THREE.Vector3();
    this.previousEarthScale=0;

    // パネルが閉じたらハイライト解除
    this.el.sceneEl.addEventListener('panel-closed', () => {
      this.currentMarkers.forEach(marker => {
        var mesh = marker.getObject3D('mesh');
        if (mesh) mesh.material.color.set('yellow');
      });
    });

    var sheetUrl="https://docs.google.com/spreadsheets/d/e/2PACX-1vSOToLaddWpng4D3j-FoN9rHXteriNlykqGJ5VJIUqhvxVKKdrTJ_dfEpgXxXC9hd-YcbfaodERb01x/pub?gid=0&single=true&output=csv";
    try{
      var res=await fetch(sheetUrl,{cache:'no-store'});
      if(res.ok){
        var text=await res.text();
        this.allLocations=this.parseCsv(text);
      }else{
        console.error('CSV fetch failed:', res.status);
      }
    }catch(e){ console.error("データ取得エラー:",e); }
    this.updateClusters();
    this.previousEarthScale=this.el.object3D.scale.x;
  },
  parseCsv:function(csvText){
    var locations=[]; var lines=csvText.trim().split('\n');
    var startIndex=lines[0].toLowerCase().includes('title')?1:0;
    for(var i=startIndex;i<lines.length;i++){
      var parts=lines[i].trim().split(',');
      if(parts.length>=4){
        locations.push({ title:parts[0].replace(/"/g,''), lat:parseFloat(parts[1]), lon:parseFloat(parts[2]), url:parts[3].replace(/"/g,'') });
      }
    }
    return locations;
  },
  updateClusters:function(){
    this.currentMarkers.forEach(m=>{ if(m && m.parentNode) m.parentNode.removeChild(m); });
    this.currentMarkers=[];

    var s=this.el.object3D.scale.x;

    // 正規化を earth-controls の min/max に合わせる
    var ec = this.el.components['earth-controls'];
    var min = ec ? ec.minScale : 1.0;
    var max = ec ? ec.maxScale : 3.0;
    var t = (s - min) / (max - min); t = Math.max(0, Math.min(1, t));

    // クラスタ距離しきい値（t で補間）
    var th = 0.2 - t * (0.2 - 0.0035);

    var unclustered=this.allLocations.slice();
    var clusters=[];
    while(unclustered.length>0){
      var p=unclustered.shift();
      var cluster=[p];
      var rest=[];
      for(var i2=0;i2<unclustered.length;i2++){
        var q=unclustered[i2];
        var dist=this.haversineDistance(p,q);
        if(dist<th) cluster.push(q); else rest.push(q);
      }
      unclustered=rest; clusters.push(cluster);
    }
    this.placeMarkersFromClusters(clusters);
  },
  placeMarkersFromClusters:function(clusters){
    var R=this.el.getAttribute('geometry').radius;
    var self=this;
    clusters.forEach(function(cluster){
      var lat=0,lon=0; cluster.forEach(function(p){lat+=p.lat;lon+=p.lon;}); lat/=cluster.length; lon/=cluster.length;

      var pos=self.latLonTo3D(lat,lon,R);
      var marker=document.createElement('a-entity'); marker.setAttribute('position',pos);

      var yAxis=pos.clone().normalize(), worldUp=new THREE.Vector3(0,1,0);
      var xAxis=new THREE.Vector3().crossVectors(worldUp,yAxis).normalize(); if(xAxis.length()===0) xAxis.set(1,0,0);
      var zAxis=new THREE.Vector3().crossVectors(xAxis,yAxis);
      var rotM=new THREE.Matrix4().makeBasis(xAxis,yAxis,zAxis);
      marker.object3D.quaternion.setFromRotationMatrix(rotM);

      marker.setAttribute('hex-marker',{count:cluster.length});
      marker.classList.add('collidable');
      marker.dataset.locations=JSON.stringify(cluster);

      marker.addEventListener('mouseenter',function(){ if(window.__panelOpen) return; var mesh=marker.getObject3D('mesh'); if(mesh) mesh.material.color.set('green'); });
      marker.addEventListener('mouseleave',function(){ if(window.__panelOpen) return; var mesh=marker.getObject3D('mesh'); if(mesh) mesh.material.color.set('yellow'); });
      marker.addEventListener('click', function(e){ if(window.__panelOpen) return; openPanel(JSON.parse(e.currentTarget.dataset.locations)); });

      self.el.appendChild(marker);
      self.currentMarkers.push(marker);
    });
    refreshAllRaycasters();
  },
  haversineDistance:function(a,b){
    function toRad(x){ return x*Math.PI/180; }
    var dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
    var lat1=toRad(a.lat), lat2=toRad(b.lat);
    var h=Math.sin(dLat/2)*Math.sin(dLat/2) + Math.sin(dLon/2)*Math.sin(dLon/2)*Math.cos(lat1)*Math.cos(lat2);
    return 2*Math.atan2(Math.sqrt(h),Math.sqrt(1-h));
  },
  tick:function(){
    if(this.currentMarkers.length===0 || !this.cameraEl) return;
    var s=this.el.object3D.scale.x;
    if(Math.abs(s-this.previousEarthScale)>0.1){ this.updateClusters(); this.previousEarthScale=s; }

    this.el.object3D.getWorldPosition(this.earthPos);
    this.cameraEl.object3D.getWorldPosition(this.cameraPos);

    // earth-controls の min/max に基づく正規化
    var ec = this.el.components['earth-controls'];
    var min = ec ? ec.minScale : 1.0;
    var max = ec ? ec.maxScale : 3.0;
    var t = (s - min) / (max - min); t = Math.max(0, Math.min(1, t));

    // 最小ズーム→maxMarkerMultiplier、最大ズーム→minMarkerMultiplier
    var a = this.data.maxMarkerMultiplier, b = this.data.minMarkerMultiplier;
    var markerScale = a - t * (a - b);

    for(var i=0;i<this.currentMarkers.length;i++){
      var marker=this.currentMarkers[i];
      marker.object3D.scale.set(markerScale,markerScale,markerScale);

      marker.object3D.getWorldPosition(this.markerPos);
      var normal=this.markerPos.clone().sub(this.earthPos).normalize();
      var camDir=this.markerPos.clone().sub(this.cameraPos).normalize();
      var visible=(normal.dot(camDir)<0);
      marker.object3D.visible=visible;
      if(marker.textEl) marker.textEl.object3D.visible=visible;
    }
  },
  latLonTo3D:function(lat,lon,R){
    var phi=(90-lat)*(Math.PI/180), theta=(lon+180)*(Math.PI/180);
    return new THREE.Vector3(
      -(R*Math.sin(phi)*Math.cos(theta)),
      R*Math.cos(phi),
      R*Math.sin(phi)*Math.sin(theta)
    );
  }
});
</script>

<a-scene
  renderer="highRefreshRate: true"
  vr-mode-ui="enabled: true"
  webxr="requiredFeatures: local-floor; optionalFeatures: bounded-floor, layers">

  <a-light type="ambient" color="#CCC"></a-light>
  <a-light type="directional" position="-1 1 2" intensity="0.5"></a-light>

  <!-- ★ ここで min-marker-multiplier を上げると最大ズーム時のクラスタが大きくなる -->
  <a-sphere id="earth" position="0 1.5 -7" radius="2" scale="1 1 1"
            src="eartn_model/world.topo.200409.3x10800x5400.jpg"
            segments-height="64" segments-width="128"
            earth-controls
            marker-placer="max-marker-multiplier:20; min-marker-multiplier:1">
  </a-sphere>

  <a-entity id="rig">
    <a-entity id="camera" camera="near: 0.01; far: 1000" position="0 1.6 0" look-controls="enabled: false">
      <a-entity id="mouseCursor"
                cursor="rayOrigin: mouse; fuse: false"
                raycaster="objects: .collidable, .ui; useWorldCoordinates: true; far: 30; interval: 0"></a-entity>
    </a-entity>

    <a-entity id="left-hand" oculus-touch-controls="hand: left; model: false;"></a-entity>

    <a-entity id="right-hand"
              laser-controls="hand: right"
              raycaster="objects: .collidable, .ui; useWorldCoordinates: true; far: 30; interval: 0; showLine: true"
              cursor="rayOrigin: entity; fuse: false; downEvents: triggerdown, selectstart; upEvents: triggerup, selectend">
    </a-entity>
  </a-entity>
  
  <!-- 画面内の地球操作UI（カメラ近傍） -->
  <a-entity id="ui-panel" position="-0.08 1.595 -0.1" rotation="0 0 0" scale="0.05 0.05 0.05">
    <a-entity geometry="primitive: plane; width: 0.5; height: 0.7"
              material="color: #333; opacity: 0.7"></a-entity>
              
    <a-entity id="btn-rot-up" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 0.25 0.01">
      <a-entity troika-text="value: ▲; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-rot-down" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 -0.25 0.01">
      <a-entity troika-text="value: ▼; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-rot-left" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="-0.14 0 0.01">
      <a-entity troika-text="value: ◀; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-rot-right" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.165 0 0.01">
      <a-entity troika-text="value: ▶; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>

    <a-entity id="btn-zoom-in" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 0.07 0.01">
      <a-entity troika-text="value: +; color: #FFF; fontSize: 0.2; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-zoom-out" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 -0.07 0.01">
      <a-entity troika-text="value: -; color: #FFF; fontSize: 0.3; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
  </a-entity>

  <a-sky color="#ECECEC"></a-sky>
</a-scene>
</body>
</html>
