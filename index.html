<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebXR Earth Controls (stable, worker, vis-fix)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <!-- Troika / A-Frame troika-text -->
  <script src="https://cdn.jsdelivr.net/npm/troika-worker-utils@0.47.2/dist/troika-worker-utils.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/troika-three-utils@0.47.2/dist/troika-three-utils.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/troika-three-text@0.47.2/dist/troika-three-text.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-troika-text@0.9.0/dist/aframe-troika-text.min.js"></script>

  <style>
    @font-face{
      font-family:"NotoSansJPLocal";
      src:url("static/NotoSansJP-Regular.ttf") format("truetype");
      font-weight:400; font-style:normal; font-display:swap;
    }
    body{ margin:0; background:#eee; }
  </style>
</head>
<body>

<script>
/* ===== 共通ユーティリティ ===== */
const FONT_URL = 'static/NotoSansJP-Regular.ttf';
window.__panelOpen = false;

function refreshAllRaycasters(){
  ['#mouseCursor', '#right-hand'].forEach(function(sel){
    var el=document.querySelector(sel);
    var rc = el && el.components && el.components.raycaster;
    if(rc && rc.refreshObjects) rc.refreshObjects();
  });
}
function setRaycasterTargets(uiOnly){
  var objs = uiOnly ? '.ui' : '.collidable, .ui';
  ['#mouseCursor', '#right-hand'].forEach(function(sel){
    var el=document.querySelector(sel);
    if(el) el.setAttribute('raycaster','objects',objs);
  });
}

/* ----- テキストを前面化（Troika再同期にも耐性） ----- */
AFRAME.registerComponent('force-front',{
  schema:{ order:{type:'number',default:100010}, frames:{type:'int',default:12} },
  init:function(){ this._applied=0; },
  tick:function(){
    if(this._applied >= this.data.frames) return;
    const mesh = this.el.getObject3D('text') || this.el.getObject3D('mesh');
    if(!mesh) return;
    mesh.renderOrder = this.data.order;
    if(mesh.material){
      mesh.material.transparent = true;
      mesh.material.depthWrite  = false;
      mesh.material.depthTest   = true;
      mesh.material.depthFunc   = THREE.AlwaysDepth;
      mesh.material.side        = THREE.DoubleSide;
    }
    this._applied++;
  }
});

/* ----- パネルを“表示時の位置”にワールド固定（yOffset動的反映） ----- */
AFRAME.registerComponent('panel-world-lock',{
  schema:{
    baseDist:{type:'number',default:0.8},
    baseScale:{type:'number',default:0.8},
    margin:{type:'number',default:0.03},
    minDist:{type:'number',default:0.08},
    faceCamera:{type:'boolean',default:false},
    worldYaw:{type:'number',default:0},
    yOffset:{type:'number',default:-0.15}
  },
  init:function(){
    this.cam = document.querySelector('#camera');
    this.earth = document.querySelector('#earth');
    this._camPos   = new THREE.Vector3();
    this._earthPos = new THREE.Vector3();
    this._fwd      = new THREE.Vector3();
    this._placed   = false;
    this._baseY    = null;
  },
  update:function(oldData){
    if (!this._placed) return;
    if (oldData && oldData.yOffset !== undefined && oldData.yOffset !== this.data.yOffset){
      const dy = this.data.yOffset - oldData.yOffset;
      this.el.object3D.position.y += dy;
      this._baseY += dy;
      return;
    }
    const keys = ['baseDist','baseScale','margin','minDist','faceCamera','worldYaw'];
    if (oldData && keys.some(k => oldData[k] !== this.data[k])){
      this._placed = false;
    }
  },
  tick:function(){
    if(!this._placed) this.placeOnce();
    if(this.data.faceCamera && this.cam){
      this.cam.object3D.getWorldPosition(this._camPos);
      this.el.object3D.lookAt(this._camPos);
      const e=this.el.object3D.rotation;
      this.el.object3D.rotation.set(0,e.y,0);
    }
  },
  placeOnce:function(){
    if(this._placed || !this.cam) return;

    this.cam.object3D.getWorldPosition(this._camPos);
    this._fwd.set(0,0,-1).applyQuaternion(this.cam.object3D.quaternion).normalize();

    let dist = this.data.baseDist;

    if(this.earth){
      this.earth.object3D.getWorldPosition(this._earthPos);
      const s = this.earth.object3D.scale.x || 1;
      const R = (this.earth.getAttribute('geometry')?.radius || 1) * s;
      const along = this._earthPos.clone().sub(this._camPos).dot(this._fwd);
      const nearAlong = along - R;
      if (nearAlong <= dist + this.data.margin){
        dist = Math.max(this.data.minDist, nearAlong - this.data.margin);
      }
    }
    dist = Math.max(this.data.minDist, dist);

    const worldPos = this._camPos.clone().add(this._fwd.clone().multiplyScalar(dist));
    worldPos.y += this.data.yOffset;
    this.el.object3D.position.copy(worldPos);

    const scl = this.data.baseScale * (dist / this.data.baseDist);
    this.el.object3D.scale.set(scl, scl, scl);

    const yawRad = THREE.MathUtils.degToRad(this.data.worldYaw);
    this.el.object3D.rotation.set(0, yawRad, 0);

    this._baseY  = worldPos.y;
    this._placed = true;
  }
});

/* ===== 新デザインの3Dパネル ===== */
const PANEL_BASE = { DIST: 0.5, SCALE: 0.5, LINES: 12 };
const PANEL_POS  = { DIST: 0.8, SCALE: 0.8, YOFFSET: -0.15 }; // 位置・スケール・高さ
function safeText(s){ return String(s==null?'':s).replace(/;/g,'；'); }

function pm_btn(x,y,w,h,label,onClick){
  var e=document.createElement('a-entity');
  e.classList.add('ui','collidable');
  e.setAttribute('geometry',`primitive:plane;width:${w};height:${h}`);
  e.setAttribute('material','shader:flat; color:#2b2f36; opacity:0.95; transparent:true; side:double; depthTest:false');
  e.setAttribute('position',`${x} ${y} 0.01`);
  var t=document.createElement('a-entity'); t.classList.add('ui');
  t.setAttribute('troika-text',[
    `value:${safeText(label)}`,
    `font:${FONT_URL}`,
    'fontSize:0.04',
    'color:#fff',
    'anchor:center'
  ].join('; '));
  t.setAttribute('position','0 0 0.001');
  t.setAttribute('force-front','order:100012');
  e.appendChild(t);
  e.addEventListener('click',onClick);
  e.addEventListener('mouseenter',()=>e.setAttribute('material','color','#3a4049'));
  e.addEventListener('mouseleave',()=>e.setAttribute('material','color','#2b2f36'));
  return e;
}

function pm_liftRenderOrder(root){
  root.object3D.renderOrder = 9999;
  root.object3D.traverse(function(obj){
    if(obj.material){
      obj.material.depthTest=false;
      obj.material.transparent=true;
    }
  });
}

/* 折り返し高さを計測して自動レイアウト */
function pm_layoutWrappedList(panel){
  var items = Array.from(panel.querySelectorAll('.list-item'));
  if(!items.length) return;

  var heights = new Array(items.length).fill(0);
  var remaining = items.length;

  function placeAll(){
    var y = 0.48;
    var gap = 0.02;
    items.forEach(function(el,i){
      el.setAttribute('position', `${-0.45} ${y} 0.03`);
      y -= (Math.max(heights[i], 0.035) + gap);
    });
  }

  items.forEach(function(el,i){
    function tryMeasure(){
      var mesh = el.getObject3D('text') || el.getObject3D('mesh');
      if(!mesh){ requestAnimationFrame(tryMeasure); return; }
      var afterSync=function(){
        if(!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
        var bb = mesh.geometry.boundingBox;
        heights[i] = Math.max((bb.max.y - bb.min.y), mesh.fontSize || 0.035);
        if(--remaining===0) placeAll();
      };
      if(typeof mesh.sync === 'function'){ mesh.sync(afterSync); }
      else { requestAnimationFrame(afterSync); }
    }
    tryMeasure();
  });
}

function pm_renderList(panel, list, from){
  var root=panel.querySelector('.list-root'); root.innerHTML='';
  var end=Math.min(from+PANEL_BASE.LINES, list.length);

  for(var i=from;i<end;i++){
    var item=document.createElement('a-entity');
    item.classList.add('ui','list-item');
    item.setAttribute('troika-text',[
      `value:${safeText(list[i].title)}`,
      `font:${FONT_URL}`,
      'fontSize:0.035',
      'lineHeight:1.25',
      'color:#fff',
      'maxWidth:0.9',
      'anchor:left',
      'baseline:top',
      'outlineWidth:0.004',
      'outlineColor:#000'
    ].join('; '));
    item.setAttribute('force-front','order:100011');
    (function(url){
      item.addEventListener('click',function(){ try{ if(url) window.open(url,'_blank'); }catch(_){ } });
    })(list[i].url);
    root.appendChild(item);
  }
  pm_layoutWrappedList(panel);
}

/* 開閉API（既存呼び出し互換） */
function openPanel(locations){ openVrPanel(locations); }
function closePanel(){ closeVrPanel(); }

/* ワールド固定の3Dパネル生成（カメラ追従なし） */
function openVrPanel(locations){
  closeVrPanel();
  var scene = document.querySelector('a-scene');
  var panel=document.createElement('a-entity');
  panel.id='vrPanel';
  panel.classList.add('ui','collidable');

  panel.setAttribute('position', `0 0 -${PANEL_BASE.DIST}`);
  panel.setAttribute('rotation','0 0 0');
  panel.setAttribute('scale', `${PANEL_BASE.SCALE} ${PANEL_BASE.SCALE} ${PANEL_BASE.SCALE}`);
  panel.setAttribute(
    'panel-world-lock',
    `base-dist:${PANEL_POS.DIST}; base-scale:${PANEL_POS.SCALE}; margin:0.03; min-dist:0.08; face-camera:false; world-yaw:0; y-offset:${PANEL_POS.YOFFSET}`
  );

  var border=document.createElement('a-entity'); border.classList.add('ui');
  border.setAttribute('geometry','primitive:plane;width:1.12;height:1.22');
  border.setAttribute('material','shader:flat; color:#ffffff; opacity:0.12; transparent:true; side:double; depthTest:false');
  panel.appendChild(border);

  var bg=document.createElement('a-entity'); bg.classList.add('ui');
  bg.setAttribute('geometry','primitive:plane;width:1.1;height:1.2');
  bg.setAttribute('material','shader:flat; color:#202428; opacity:0.98; transparent:true; side:double; depthTest:false');
  panel.appendChild(bg);

  var head = locations.length ? (String(locations[0].title).split(/\s+/)[0] + ' など（' + locations.length + '件）') : 'Places';
  var title=document.createElement('a-entity'); title.classList.add('ui');
  title.setAttribute('troika-text',[
    `value:${safeText(head)}`,
    `font:${FONT_URL}`,
    'fontSize:0.05',
    'color:#CCFF00',
    'maxWidth:1.0',
    'anchor:left',
    'baseline:top',
    'outlineWidth:0.004',
    'outlineColor:#000',
    'lineHeight:1.1'
  ].join('; '));
  title.setAttribute('position','-0.45 0.55 0.03');
  title.setAttribute('force-front','order:100012');
  panel.appendChild(title);

  var listRoot=document.createElement('a-entity');
  listRoot.classList.add('ui','list-root');
  panel.appendChild(listRoot);

  var scrollIndex=0;
  function rerender(){ pm_renderList(panel, locations, scrollIndex); }

  panel.appendChild(pm_btn( 0.50, 0.55, 0.12, 0.12, '×', function(){ closeVrPanel(); }));
  panel.appendChild(pm_btn( 0.45, 0.40, 0.12, 0.12, '▲', function(){
    if(scrollIndex>0){ scrollIndex--; rerender(); }
  }));
  panel.appendChild(pm_btn( 0.45,-0.40, 0.12, 0.12, '▼', function(){
    if(scrollIndex < Math.max(0, locations.length - PANEL_BASE.LINES)){ scrollIndex++; rerender(); }
  }));

  pm_liftRenderOrder(panel);
  scene.appendChild(panel);

  rerender();

  window.__panelOpen = true;
  setRaycasterTargets(true); refreshAllRaycasters();
  document.querySelector('a-scene').emit('panel-opened');
}
function closeVrPanel(){
  var p = document.getElementById('vrPanel');
  if (p && p.parentNode) p.parentNode.removeChild(p);
  window.__panelOpen = false;
  document.querySelector('a-scene').emit('panel-closed');
  setRaycasterTargets(false); refreshAllRaycasters();
}
</script>

<script>
/* ============ Earth Controls（VR安定・非VR互換） ============ */
AFRAME.registerComponent('earth-controls',{
  schema:{
    rotationSpeed:{type:'number',default:2.0},
    joystickRotationSpeed:{type:'number',default:1.0},
    scaleSpeed:{type:'number',default:0.01},
    mouseRotationSpeed:{type:'number',default:0.2},
    wheelScaleSpeed:{type:'number',default:0.0005}
  },
  init:function(){
    this.minScale=1.0; this.maxScale=3.0;
    this.currentXRotation=0;
    this.keys={};
    this.stickInput={ left:{x:0,y:0}, right:{x:0,y:0} };
    this.isDragging=false;
    this.previousMousePosition={x:0,y:0};
    this.cameraEl=document.querySelector('#camera');
    
    this.uiState = { rotUp: false, rotDown: false, rotLeft: false, rotRight: false, zoomIn: false, zoomOut: false };

    var self=this;
    window.addEventListener('keydown',function(e){ self.keys[e.key]=true; });
    window.addEventListener('keyup',function(e){ self.keys[e.key]=false; });

    this.el.sceneEl.addEventListener('loaded', function(){
      var cvs=self.el.sceneEl.canvas;
      cvs.addEventListener('mousedown',function(e){ self.onMouseDown(e); });
      window.addEventListener('mousemove',function(e){ self.onMouseMove(e); });
      window.addEventListener('mouseup',function(){ self.onMouseUp(); });
      if (!AFRAME.utils.device.checkHeadsetConnected()) {
        cvs.addEventListener('wheel',function(e){ self.onWheelCanvas(e); },{passive:true});
      }
      
      self.setupUIListeners();
    });
    
    this._bindThumbsticks = function(){
      var L=document.querySelector('#left-hand');
      var R=document.querySelector('#right-hand');
      if(L && !L._thumbBound){
        L.addEventListener('thumbstickmoved', function(e){ self.stickInput.left={x:e.detail.x,y:e.detail.y}; });
        L.addEventListener('axismove', function(e){
          var a=(e.detail && e.detail.axis) ? e.detail.axis : [];
          if (self.stickInput.left.x === 0 && self.stickInput.left.y === 0) {
            self.stickInput.left={x:a[0]||0, y:a[1]||0};
          }
        });
        L._thumbBound=true;
      }
      if(R && !R._thumbBound){
        R.addEventListener('thumbstickmoved', function(e){ self.stickInput.right={x:e.detail.x,y:e.detail.y}; });
        R.addEventListener('axismove', function(e){
          var a=(e.detail && e.detail.axis) ? e.detail.axis : [];
          if (self.stickInput.right.x === 0 && self.stickInput.right.y === 0) {
            var rx = (typeof a[2] === 'number') ? a[2] : (a[0]||0);
            var ry = (typeof a[3] === 'number') ? a[3] : (a[1]||0);
            self.stickInput.right={x:rx, y:ry};
          }
        });
        R._thumbBound=true;
      }
    };

    var leftHand = document.querySelector('#left-hand');
    var rightHand = document.querySelector('#right-hand');
    
    if(leftHand)  leftHand.addEventListener('controllerconnected', this._bindThumbsticks.bind(this));
    if(rightHand) rightHand.addEventListener('controllerconnected', this._bindThumbsticks.bind(this));
  },
  
  setupUIListeners: function() {
    var self = this;
    var states = [
      { id: '#btn-rot-up',    state: 'rotUp' },
      { id: '#btn-rot-down',  state: 'rotDown' },
      { id: '#btn-rot-left',  state: 'rotLeft' },
      { id: '#btn-rot-right', state: 'rotRight' },
      { id: '#btn-zoom-in',   state: 'zoomIn' },
      { id: '#btn-zoom-out',  state: 'zoomOut' }
    ];

    states.forEach(function(item) {
      var btn = document.querySelector(item.id);
      if (btn) {
        btn.addEventListener('mousedown', function() { self.uiState[item.state] = true; });
        btn.addEventListener('mouseup', function() { self.uiState[item.state] = false; });
        btn.addEventListener('mouseleave', function() { self.uiState[item.state] = false; });
      }
    });
  },

  onMouseDown:function(evt){
    if (evt.target.classList.contains('ui')) return;
    if(window.__panelOpen) return;
    this.isDragging=true;
    this.previousMousePosition={x:evt.clientX,y:evt.clientY};
    if(this.cameraEl) this.cameraEl.setAttribute('look-controls','enabled',false);
  },
  onMouseMove:function(evt){
    if(!this.isDragging || window.__panelOpen) return;
    var dx=evt.clientX-this.previousMousePosition.x;
    var dy=evt.clientY-this.previousMousePosition.y;
    this.el.object3D.rotation.y += dx*(Math.PI/180)*this.data.mouseRotationSpeed;
    this.currentXRotation += dy*this.data.mouseRotationSpeed;
    this.previousMousePosition={x:evt.clientX,y:evt.clientY};
  },
  onMouseUp:function(){ this.isDragging=false; },
  onWheelCanvas:function(evt){
    if(window.__panelOpen) return;
    var s=this.el.object3D.scale.x;
    s += evt.deltaY*-1*this.data.wheelScaleSpeed;
    var ns=Math.max(this.minScale,Math.min(this.maxScale,s));
    this.el.object3D.scale.set(ns,ns,ns);
  },
  getNonVrSticks:function(){
    var pads = (navigator.getGamepads && navigator.getGamepads()) ? navigator.getGamepads() : [];
    var p = null;
    for (var i=0;i<pads.length;i++){ if(pads[i] && pads[i].connected){ p=pads[i]; break; } }
    if(!p) return null;
    var ax = p.axes || [];
    return { left:{x:ax[0]||0, y:ax[1]||0}, right:{x:ax[2]||0, y:ax[3]||0} };
  },
  tick: function() {
    if (window.__panelOpen) return;

    var rotY_k = (this.keys['ArrowLeft'] ? -1 : 0) + (this.keys['ArrowRight'] ? 1 : 0);
    var rotX_k = (this.keys['ArrowUp'] ? -1 : 0) + (this.keys['ArrowDown'] ? 1 : 0);
    var scale_k = (this.keys['w'] || this.keys['W'] ? 1 : 0) + (this.keys['s'] || this.keys['S'] ? -1 : 0);
    
    var rotY_ui = (this.uiState.rotRight ? 1 : 0) + (this.uiState.rotLeft ? -1 : 0);
    var rotX_ui = (this.uiState.rotDown ? 1 : 0) + (this.uiState.rotUp ? -1 : 0);
    var scale_ui = (this.uiState.zoomIn ? 1 : 0) + (this.uiState.zoomOut ? -1 : 0);

    var stickRotX = this.stickInput.right.y;
    var stickRotY = this.stickInput.right.x;
    var stickScale = this.stickInput.left.y;

    if (stickRotX === 0 && stickRotY === 0 && stickScale === 0) {
      var gp = this.getNonVrSticks();
      if (gp) {
        stickRotX = gp.right.y; stickRotY = gp.right.x; stickScale = gp.left.y;
      }
    }
    
    var s = this.el.object3D.scale.x;
    var t = (s - this.minScale) / (this.maxScale - this.minScale);
    t = Math.max(0, Math.min(1, t));
    var mul = 1 - (t * (7 / 8));
    
    var finalRotY = (stickRotY !== 0 ? stickRotY * this.data.joystickRotationSpeed : (rotY_ui !== 0 ? rotY_ui * this.data.rotationSpeed : rotY_k * this.data.rotationSpeed)) * mul;
    var finalRotX = (stickRotX !== 0 ? stickRotX * this.data.joystickRotationSpeed : (rotX_ui !== 0 ? rotX_ui * this.data.rotationSpeed : rotX_k * this.data.rotationSpeed)) * mul;
    var finalScale = (stickScale !== 0 ? -stickScale : (scale_ui !== 0 ? scale_ui : scale_k)) * this.data.scaleSpeed;

    this.el.object3D.rotation.y += finalRotY * (Math.PI / 180);
    this.currentXRotation = Math.max(-80, Math.min(80, this.currentXRotation + finalRotX));
    this.el.object3D.rotation.x = this.currentXRotation * (Math.PI / 180);

    var ns = s + finalScale;
    ns = Math.max(this.minScale, Math.min(this.maxScale, ns));
    this.el.object3D.scale.set(ns, ns, ns);
  }
});
</script>

<script>
/* ============ hex-marker（更新対応・再利用） ============ */
AFRAME.registerComponent('hex-marker',{
  schema:{
    count:{type:'number',default:1},
    color:{type:'color',default:'yellow'},
    baseRadius:{type:'number',default:0.0075},
    heightUnit:{type:'number',default:0.0001},
    fontUrl:{type:'string',default:FONT_URL}
  },
  init:function(){ this._build(this.data.count); },
  update:function(old){
    if (old && old.count !== this.data.count) this._updateVisual(this.data.count);
    if (old && old.color !== this.data.color) {
      const mesh=this.el.getObject3D('mesh'); if(mesh) mesh.material.color.set(this.data.color);
    }
  },
  _build:function(count){
    const d=this.data;
    this.height=0.01+(count*d.heightUnit);
    const geom=new THREE.CylinderGeometry(d.baseRadius*0.7,d.baseRadius,this.height,6);
    const mat =new THREE.MeshStandardMaterial({color:d.color,flatShading:true});
    const mesh=new THREE.Mesh(geom,mat);
    this.el.setObject3D('mesh', mesh);

    const text=document.createElement('a-entity');
    text.setAttribute('troika-text',{
      value:String(count),
      font:d.fontUrl,
      fontSize:d.baseRadius*0.7,
      color:'#111',
      outlineColor:'#fff',
      outlineWidth:0.0006,
      outlineBlur:0.00001,
      anchor:'center'
    });
    text.setAttribute('rotation','-90 0 0');
    text.setAttribute('position',{x:0,y:this.height/2+0.00012,z:0});
    this.el.appendChild(text);
    this.textEl=text;
  },
  _updateVisual:function(count){
    const d=this.data;
    this.height=0.01+(count*d.heightUnit);
    const mesh=this.el.getObject3D('mesh');
    if (mesh) {
      mesh.geometry.dispose();
      mesh.geometry=new THREE.CylinderGeometry(d.baseRadius*0.7,d.baseRadius,this.height,6);
    }
    if (this.textEl) {
      this.textEl.setAttribute('troika-text','value',String(count));
      this.textEl.setAttribute('position',{x:0,y:this.height/2+0.00012,z:0});
    }
  }
});
</script>

<script>
/* ======== Web Worker（クラスタリング） ======== */
function createClusterWorker(){
  const source = `
  let POINTS = []; // {lat,lon,url,title,v:[x,y,z]}
  function computeThreshold(s,min,max){
    const t = Math.max(0, Math.min(1, (s - min) / (max - min)));
    return 0.2 - t * (0.2 - 0.008); // radians
  }
  function buildGrid(points, cellSizeChord){
    const cs = Math.max(0.02, Math.min(0.5, cellSizeChord));
    const inv = 1.0 / cs;
    const grid = new Map();
    const keyOf = (x,y,z)=> (Math.floor((x+1)*inv)+","+Math.floor((y+1)*inv)+","+Math.floor((z+1)*inv));
    for(let i=0;i<points.length;i++){
      const [x,y,z]=points[i].v;
      const k=keyOf(x,y,z);
      let arr=grid.get(k); if(!arr){ arr=[]; grid.set(k,arr); }
      arr.push(i);
    }
    return {grid,inv,cs};
  }
  function neighborCandidates(v, gridObj){
    const [x,y,z]=v;
    const {grid,inv} = gridObj;
    const ix=Math.floor((x+1)*inv), iy=Math.floor((y+1)*inv), iz=Math.floor((z+1)*inv);
    const out=[];
    for(let dx=-1;dx<=1;dx++){
      for(let dy=-1;dy<=1;dy++){
        for(let dz=-1;dz<=1;dz++){
          const a = grid.get((ix+dx)+","+(iy+dy)+","+(iz+dz));
          if(a) out.push(a);
        }
      }
    }
    return out.length ? out.reduce((acc,cur)=>(acc.push.apply(acc,cur),acc),[]) : [];
  }
  self.onmessage = function(e){
    const d=e.data;
    if(d.cmd==='init'){
      POINTS = d.points||[];
      self.postMessage({cmd:'inited', count:POINTS.length});
    }else if(d.cmd==='recluster'){
      const s=d.scale, min=d.minScale||1.0, max=d.maxScale||3.0;
      const th=computeThreshold(s,min,max);
      const cosTh=Math.cos(th);
      const chord = 2*Math.sin(th/2);
      const gridObj=buildGrid(POINTS, chord);

      const used = new Uint8Array(POINTS.length);
      const clustersIdx=[];
      for(let i=0;i<POINTS.length;i++){
        if(used[i]) continue;
        used[i]=1;
        const seed=POINTS[i], seedV=seed.v;
        const cand = neighborCandidates(seedV, gridObj);
        const cluster=[i];
        for(let k=0;k<cand.length;k++){
          const j=cand[k]; if(j===i || used[j]) continue;
          const v=POINTS[j].v;
          const dot = seedV[0]*v[0] + seedV[1]*v[1] + seedV[2]*v[2];
          if(dot >= cosTh){ cluster.push(j); used[j]=1; }
        }
        clustersIdx.push(cluster);
      }
      self.postMessage({cmd:'clusters', clustersIdx});
    }
  }`;
  const blob = new Blob([source], {type:'application/javascript'});
  return new Worker(URL.createObjectURL(blob));
}
</script>

<script>
/* ============ marker-placer（Worker版・高速） ============ */
AFRAME.registerComponent('marker-placer',{
  schema:{
    maxMarkerMultiplier:{type:'number',default:20}, // 最小ズーム時サイズ
    minMarkerMultiplier:{type:'number',default:3},  // 最大ズーム時（最小サイズ）
    recalcMinIntervalMs:{type:'number',default:80}, // スロットル(時間)
    recalcScaleEpsilon:{type:'number',default:0.06} // スロットル(スケール差)
  },
  init:async function(){
    this.allLocations=[];          // {title,lat,lon,url,v:[x,y,z]}
    this.currentMarkers=[];        // プール
    this._activeMarkers=0;         // ★ 現役マーカー数（←追加）
    this.cameraEl=document.querySelector('#camera');
    this.cameraPos=new THREE.Vector3();
    this.markerPos=new THREE.Vector3();
    this.earthPos =new THREE.Vector3();

    this.previousEarthScale=0;
    this._lastRecalc=0;
    this._workerBusy=false;
    this._pending=false;
    this._worker=null;
    this._inited=false;

    // パネル閉で色戻す
    this.el.sceneEl.addEventListener('panel-closed', () => {
      this.currentMarkers.slice(0,this._activeMarkers).forEach(m => {
        const mesh=m.getObject3D('mesh'); if(mesh) mesh.material.color.set('yellow');
      });
    });

    // CSV 取得
    const sheetUrl="https://docs.google.com/spreadsheets/d/e/2PACX-1vSOToLaddWpng4D3j-FoN9rHXteriNlykqGJ5VJIUqhvxVKKdrTJ_dfEpgXxXC9hd-YcbfaodERb01x/pub?gid=0&single=true&output=csv";
    try{
      const res=await fetch(sheetUrl,{cache:'no-store'});
      if(res.ok){
        const text=await res.text();
        const raw=this.parseCsv(text);
        this.allLocations = raw.map(r=>{
          const radLat = r.lat * Math.PI/180;
          const radLon = r.lon * Math.PI/180;
          const x = Math.cos(radLat)*Math.cos(radLon);
          const y = Math.sin(radLat);
          const z = Math.cos(radLat)*Math.sin(radLon);
          return {...r, v:[x,y,z]};
        });
      } else {
        console.error('CSV fetch failed:', res.status);
      }
    }catch(e){ console.error("データ取得エラー:",e); }

    // Worker 準備＆初回クラスタ
    this.setupWorker();
  },

  setupWorker:function(){
    this._worker = createClusterWorker();
    this._worker.onmessage = (e)=>{
      const d=e.data;
      if(d.cmd==='inited'){
        this._inited=true;
        this.reclusterNow(); // 初回
      }else if(d.cmd==='clusters'){
        this._workerBusy=false;
        this.applyClustersFromIdx(d.clustersIdx);
        if (this._pending) { this._pending=false; this.reclusterNow(); }
      }
    };
    this._worker.postMessage({cmd:'init', points:this.allLocations});
  },

  parseCsv:function(csvText){
    const locations=[]; const lines=csvText.trim().split('\n');
    const startIndex=lines[0].toLowerCase().includes('title')?1:0;
    for(let i=startIndex;i<lines.length;i++){
      const parts=lines[i].trim().split(',');
      if(parts.length>=4){
        locations.push({
          title:parts[0].replace(/"/g,''),
          lat:parseFloat(parts[1]),
          lon:parseFloat(parts[2]),
          url:parts[3].replace(/"/g,'')
        });
      }
    }
    return locations;
  },

  reclusterNow:function(){
    if(!this._inited || !this._worker) return;
    const s=this.el.object3D.scale.x;
    const ec=this.el.components['earth-controls'];
    const min=ec?ec.minScale:1.0;
    const max=ec?ec.maxScale:3.0;

    if (this._workerBusy){ this._pending=true; return; }
    this._workerBusy=true;
    this._worker.postMessage({cmd:'recluster', scale:s, minScale:min, maxScale:max});
    this._lastRecalc=performance.now();
    this.previousEarthScale=s;
  },

  applyClustersFromIdx:function(clustersIdx){
    const R=this.el.getAttribute('geometry').radius;

    for(let i=0;i<clustersIdx.length;i++){
      let marker=this.currentMarkers[i];
      if(!marker){
        marker=document.createElement('a-entity');
        marker.classList.add('collidable');
        marker.setAttribute('hex-marker',{count:clustersIdx[i].length});
        marker.addEventListener('mouseenter',()=>{
          if(window.__panelOpen) return;
          const mesh=marker.getObject3D('mesh'); if(mesh) mesh.material.color.set('green');
        });
        marker.addEventListener('mouseleave',()=>{
          if(window.__panelOpen) return;
          const mesh=marker.getObject3D('mesh'); if(mesh) mesh.material.color.set('yellow');
        });
        marker.addEventListener('click',()=>{
          if(window.__panelOpen) return;
          const idxs = marker._idxs || [];
          const clusterObjs = idxs.map(j=>this.allLocations[j]);
          openPanel(clusterObjs);
        });
        this.el.appendChild(marker);
        this.currentMarkers[i]=marker;
      }

      const idxs=clustersIdx[i];
      marker._idxs = idxs;

      // クラスタ中心（lat/lon平均）
      let lat=0, lon=0;
      for(let k=0;k<idxs.length;k++){
        const p=this.allLocations[idxs[k]];
        lat+=p.lat; lon+=p.lon;
      }
      lat/=idxs.length; lon/=idxs.length;

      const pos=this.latLonTo3D(lat,lon,R);
      marker.setAttribute('position', pos);

      const yAxis=pos.clone().normalize(), worldUp=new THREE.Vector3(0,1,0);
      const xAxis=new THREE.Vector3().crossVectors(worldUp,yAxis).normalize(); if(xAxis.length()===0) xAxis.set(1,0,0);
      const zAxis=new THREE.Vector3().crossVectors(xAxis,yAxis);
      const rotM=new THREE.Matrix4().makeBasis(xAxis,yAxis,zAxis);
      marker.object3D.quaternion.setFromRotationMatrix(rotM);

      // カウント更新
      marker.setAttribute('hex-marker','count',idxs.length);

      // いったん表示ON（可視/不可視はtickで決定）
      marker.object3D.visible=true;
      if(marker.textEl) marker.textEl.object3D.visible=true;
    }

    // 余剰は非表示（退役）
    for(let i=clustersIdx.length;i<this.currentMarkers.length;i++){
      const m=this.currentMarkers[i];
      if(m){ m.object3D.visible=false; if(m.textEl) m.textEl.object3D.visible=false; }
    }

    // ★ 現役数を記録（tickはこの数だけ処理）
    this._activeMarkers = clustersIdx.length;

    refreshAllRaycasters();
  },

  tick:function(time){
    if(this.allLocations.length===0 || !this.cameraEl) return;

    const s=this.el.object3D.scale.x;
    const needByScale = Math.abs(s - this.previousEarthScale) > this.data.recalcScaleEpsilon;
    const needByTime  = (time - this._lastRecalc) > this.data.recalcMinIntervalMs;
    if (needByScale && needByTime) this.reclusterNow();

    // 可視性・スケールは毎フレーム更新（★ 非表示も含めて評価するため、スキップしない）
    this.el.object3D.getWorldPosition(this.earthPos);
    this.cameraEl.object3D.getWorldPosition(this.cameraPos);

    const ec=this.el.components['earth-controls'];
    const min=ec?ec.minScale:1.0;
    const max=ec?ec.maxScale:3.0;
    const t = Math.max(0, Math.min(1, (s - min) / (max - min)));

    const a=this.data.maxMarkerMultiplier, b=this.data.minMarkerMultiplier;
    const markerScale = a - t * (a - b);

    // ★ 退役（余剰）マーカーは対象外：0.._activeMarkers-1 のみ
    for(let i=0;i<this._activeMarkers;i++){
      const marker=this.currentMarkers[i];
      if(!marker) continue;

      marker.object3D.scale.set(markerScale,markerScale,markerScale);

      marker.object3D.getWorldPosition(this.markerPos);
      const normal=this.markerPos.clone().sub(this.earthPos).normalize();
      const camDir=this.markerPos.clone().sub(this.cameraPos).normalize();
      const visible=(normal.dot(camDir)<0); // 前面=表示

      marker.object3D.visible=visible;
      if(marker.textEl) marker.textEl.object3D.visible=visible;
    }
  },

  latLonTo3D:function(lat,lon,R){
    const phi=(90-lat)*(Math.PI/180), theta=(lon+180)*(Math.PI/180);
    return new THREE.Vector3(
      -(R*Math.sin(phi)*Math.cos(theta)),
      R*Math.cos(phi),
      R*Math.sin(phi)*Math.sin(theta)
    );
  }
});
</script>

<a-scene
  renderer="highRefreshRate: true"
  vr-mode-ui="enabled: true"
  webxr="requiredFeatures: local-floor; optionalFeatures: bounded-floor, layers">

  <a-light type="ambient" color="#CCC"></a-light>
  <a-light type="directional" position="-1 1 2" intensity="0.5"></a-light>

  <!-- 地球 -->
  <a-sphere id="earth" position="0 1.5 -7" radius="2" scale="1 1 1"
            src="eartn_model/world.topo.200409.3x10800x5400.jpg"
            segments-height="64" segments-width="128"
            earth-controls
            marker-placer="max-marker-multiplier:20; min-marker-multiplier:3">
  </a-sphere>

  <a-entity id="rig">
    <a-entity id="camera" camera="near: 0.01; far: 1000" position="0 1.6 0" look-controls="enabled: false">
      <a-entity id="mouseCursor"
                cursor="rayOrigin: mouse; fuse: false"
                raycaster="objects: .collidable, .ui; useWorldCoordinates: true; far: 30; interval: 0; enabled: false"></a-entity>
    </a-entity>

    <a-entity id="left-hand" oculus-touch-controls="hand: left; model: false;"></a-entity>

    <a-entity id="right-hand"
              laser-controls="hand: right"
              raycaster="objects: .collidable, .ui; useWorldCoordinates: true; far: 30; interval: 0; showLine: true"
              cursor="rayOrigin: entity; fuse: false; downEvents: triggerdown, selectstart; upEvents: triggerup, selectend">
    </a-entity>
  </a-entity>
  
  <!-- 画面内の地球操作UI（カメラ近傍） -->
  <a-entity id="ui-panel" position="-0.08 1.595 -0.1" rotation="0 0 0" scale="0.05 0.05 0.05">
    <a-entity geometry="primitive: plane; width: 0.5; height: 0.7"
              material="color: #333; opacity: 0.7"></a-entity>
              
    <a-entity id="btn-rot-up" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 0.25 0.01">
      <a-entity troika-text="value: ▲; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-rot-down" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 -0.25 0.01">
      <a-entity troika-text="value: ▼; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-rot-left" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="-0.14 0 0.01">
      <a-entity troika-text="value: ◀; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-rot-right" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.165 0 0.01">
      <a-entity troika-text="value: ▶; color: #FFF; fontSize: 0.1; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>

    <a-entity id="btn-zoom-in" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 0.07 0.01">
      <a-entity troika-text="value: +; color: #FFF; fontSize: 0.2; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
    <a-entity id="btn-zoom-out" class="ui collidable"
              geometry="primitive: plane; width: 0.15; height: 0.15" material="transparent: true; opacity: 0"
              position="0.01 -0.07 0.01">
      <a-entity troika-text="value: -; color: #FFF; fontSize: 0.3; align: center; anchor: center; font: static/NotoSansJP-Regular.ttf;" position="0 0 0.01"></a-entity>
    </a-entity>
  </a-entity>

  <a-sky color="#ECECEC"></a-sky>
</a-scene>

<!-- ▼ 非VRでは右手レーザーを無効化。VR入室時のみ有効化
     ▼ マウスRaycasterは初期OFF。最初のユーザー操作でON -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const scene  = document.querySelector('a-scene');
  const right  = document.querySelector('#right-hand');
  const mouseC = document.querySelector('#mouseCursor');

  function setRightHand(enabled) {
    if (!right) return;
    right.setAttribute('raycaster', 'enabled', enabled);
    right.setAttribute('cursor',    'enabled', enabled);
  }

  // 非VRで右手レーザーOFF
  scene.addEventListener('loaded', () => {
    if (!AFRAME.utils.device.checkHeadsetConnected()) {
      setRightHand(false);
    }
  });
  scene.addEventListener('enter-vr', () => setRightHand(true));
  scene.addEventListener('exit-vr',  () => setRightHand(false));

  // 起動直後の誤ヒットを避けるため、マウスRaycasterは初期OFF→最初の実入力でON
  function enableMouseRayOnce(){
    if (mouseC && mouseC.components && mouseC.components.raycaster) {
      mouseC.setAttribute('raycaster','enabled',true);
      refreshAllRaycasters();
    }
    window.removeEventListener('mousemove', enableMouseRayOnce);
    window.removeEventListener('mousedown', enableMouseRayOnce);
  }
  window.addEventListener('mousemove', enableMouseRayOnce);
  window.addEventListener('mousedown', enableMouseRayOnce);
});
</script>
<!-- ▲ 非VRレーザーOFF／マウスRay初期OFF -->
</body>
</html>
