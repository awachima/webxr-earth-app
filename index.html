<!DOCTYPE html>
<html>
<head>
  <title>WebXR Earth Controls</title>
  <!-- 正しく動作したA-Frameのライブラリ -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
</head>
<body>
  <!-- JavaScriptで独自の操作機能を定義 -->
  <script>
    // 'earth-controls'という名前の新しい部品（コンポーネント）を定義します
    AFRAME.registerComponent('earth-controls', {
      // 初期設定
      schema: {
        rotationSpeed: { type: 'number', default: 2.0 }, // 回転の速さ
        scaleSpeed: { type: 'number', default: 0.01 }   // 拡大・縮小の速さ
      },

      // コンポーネントが初期化されるときに一度だけ呼ばれる関数
      init: function () {
        // 変数の準備
        this.minScale = 1.0;
        this.maxScale = 3.0;
        this.currentXRotation = 0;
        this.keys = {}; // 押されているキーの状態
        this.stickInput = { left: {x: 0, y: 0}, right: {x: 0, y: 0} }; // スティックの入力状態

        // --- イベントリスナーの登録 ---
        this.onStickMoved = this.onStickMoved.bind(this);
        this.el.sceneEl.addEventListener('thumbstickmoved', this.onStickMoved);

        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        window.addEventListener('keydown', this.onKeyDown);
        window.addEventListener('keyup', this.onKeyUp);
      },
      
      onKeyDown: function (evt) { this.keys[evt.key] = true; },
      onKeyUp: function (evt) { this.keys[evt.key] = false; },

      // VRコントローラーのスティックが動いた時の処理
      onStickMoved: function (evt) {
        if (evt.target.id === 'left-hand') {
          this.stickInput.left = evt.detail;
        } else if (evt.target.id === 'right-hand') {
          this.stickInput.right = evt.detail;
        }
      },

      // 毎フレーム呼ばれる更新処理 (tick)
      tick: function () {
        // --- 入力値の取得 ---
        const rotY_keyboard = (this.keys['ArrowLeft'] ? -1 : 0) + (this.keys['ArrowRight'] ? 1 : 0);
        const rotX_keyboard = (this.keys['ArrowUp'] ? -1 : 0) + (this.keys['ArrowDown'] ? 1 : 0);
        const scale_keyboard = (this.keys['w'] || this.keys['W'] ? 1 : 0) + (this.keys['s'] || this.keys['S'] ? -1 : 0);

        // スケールに基づいて回転速度の倍率を計算
        const currentScaleValue = this.el.object3D.scale.x;
        const t = (currentScaleValue - this.minScale) / (this.maxScale - this.minScale);
        const rotationMultiplier = 1 - (t * (7 / 8));

        // --- 値の計算 ---
        // 回転
        const finalRotY = (this.stickInput.right.x !== 0 ? this.stickInput.right.x : rotY_keyboard) * this.data.rotationSpeed * rotationMultiplier;
        const finalRotX = (this.stickInput.right.y !== 0 ? this.stickInput.right.y : rotX_keyboard) * this.data.rotationSpeed * rotationMultiplier;
        
        // 拡縮
        const finalScale = (this.stickInput.left.y !== 0 ? -this.stickInput.left.y : scale_keyboard) * this.data.scaleSpeed;

        // --- 計算結果の適用 ---
        this.el.object3D.rotation.y += finalRotY * (Math.PI / 180);
        this.currentXRotation -= finalRotX;
        this.currentXRotation = Math.max(-80, Math.min(80, this.currentXRotation));
        this.el.object3D.rotation.x = this.currentXRotation * (Math.PI / 180);

        let newScale = currentScaleValue + finalScale;
        newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
        this.el.object3D.scale.set(newScale, newScale, newScale);
      },

      remove: function() {
        this.el.sceneEl.removeEventListener('thumbstickmoved', this.onStickMoved);
        window.removeEventListener('keydown', this.onKeyDown);
        window.removeEventListener('keyup', this.onKeyUp);
      }
    });

    // 六角柱マーカーを生成する新しいコンポーネント
    AFRAME.registerComponent('hex-marker', {
        schema: {
            count: {type: 'number', default: 1},
            color: {type: 'color', default: 'yellow'},
            baseRadius: {type: 'number', default: 0.0075},
            heightUnit: {type: 'number', default: 0.0005}
        },
        init: function() {
            const data = this.data;
            // デフォルトの高さを0.01に変更
            this.height = 0.01 + (data.count * data.heightUnit);
            
            // 裾が少し広がった六角柱のジオメトリを作成
            const geometry = new THREE.CylinderGeometry(data.baseRadius * 0.9, data.baseRadius, this.height, 6);
            // flatShading: true を追加して、表示をカクカクさせる
            const material = new THREE.MeshStandardMaterial({color: data.color, flatShading: true});
            const mesh = new THREE.Mesh(geometry, material);
            this.el.setObject3D('mesh', mesh);

            // マーカー表面に表示するテキストを作成
            const textEntity = document.createElement('a-text');
            textEntity.setAttribute('value', data.count);
            // テキストが六角柱の上面と平行になるように回転
            textEntity.setAttribute('rotation', {x: -90, y: 0, z: 0});
            textEntity.setAttribute('align', 'center');
            textEntity.setAttribute('color', 'black');
            // マーカーのサイズに合わせてテキストの幅を調整
            textEntity.setAttribute('width', 0.1);
            
            this.el.appendChild(textEntity);
            this.textEntity = textEntity;
        },
        tick: function() {
            if (!this.textEntity) return;

            const parentScale = this.el.object3D.scale.y;
            if (parentScale === 0) return;

            // 親のスケールが大きくなるほど、隙間を小さくして、見た目の距離を一定に保つ
            const desiredGap = 0.0001;
            const adjustedGap = desiredGap / parentScale;

            this.textEntity.setAttribute('position', {x: 0, y: this.height / 2 + adjustedGap, z: 0});
        }
    });


    // マーカーを配置するためのコンポーネント
    AFRAME.registerComponent('marker-placer', {
      schema: {
        maxMarkerMultiplier: {type: 'number', default: 12}
      },
      init: function() {
        this.markers = []; // 作成したマーカーを保存する配列
        // ★★★ 2000個のランダムなサンプルデータを生成 ★★★
        const locations = [];
        for (let i = 0; i < 2000; i++) {
            locations.push({
                title: `Point ${i + 1}`,
                lat: Math.random() * 180 - 90, // -90 to 90
                lon: Math.random() * 360 - 180, // -180 to 180
                url: '...',
                count: Math.floor(Math.random() * 50) + 1 // 1 to 50
            });
        }

        // 球体の半径をコンポーネントから直接取得
        const earthRadius = this.el.getAttribute('geometry').radius;

        locations.forEach(loc => {
          // 緯度経度を3D座標に変換
          const pos = this.latLonTo3D(loc.lat, loc.lon, earthRadius);

          // a-sphereの代わりに、新しいhex-markerコンポーネントを持つa-entityを作成
          const marker = document.createElement('a-entity');
          marker.setAttribute('position', pos);

          // マーカーの向きを、北極を基準に安定させる
          const yAxis = pos.clone().normalize();
          const worldUp = new THREE.Vector3(0, 1, 0);
          const xAxis = new THREE.Vector3().crossVectors(worldUp, yAxis).normalize();
          if (xAxis.length() === 0) {
            xAxis.set(1, 0, 0);
          }
          const zAxis = new THREE.Vector3().crossVectors(xAxis, yAxis);
          const rotationMatrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
          marker.object3D.quaternion.setFromRotationMatrix(rotationMatrix);

          // countを渡してマーカーを生成
          marker.setAttribute('hex-marker', {count: loc.count});
          
          // マーカーを地球の子要素として追加
          this.el.appendChild(marker);
          this.markers.push(marker);
        });
      },

      // マーカーのスケールを毎フレーム更新するtick関数
      tick: function() {
        if (!this.markers || this.markers.length === 0) return;

        // 地球の現在のスケールを取得
        const earthScale = this.el.object3D.scale.x;

        // earthScaleが1から3の間で変化する時、tは0から1の間で変化する
        const t = (earthScale - 1) / (3 - 1); 
        // マーカーの倍率を、maxMarkerMultiplierから1まで線形補間で計算
        const markerScale = this.data.maxMarkerMultiplier - t * (this.data.maxMarkerMultiplier - 1);

        // 全てのマーカーのスケールを更新
        for (const marker of this.markers) {
            marker.object3D.scale.set(markerScale, markerScale, markerScale);
        }
      },

      // 緯度経度を3D座標に変換するヘルパー関数
      latLonTo3D: function(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);

        return new THREE.Vector3(x, y, z);
      }
    });

  </script>

  <!-- renderer="antialias: true" を追加して、描画を滑らかにする -->
  <a-scene renderer="antialias: true">
    <!-- シーンに照明を追加 -->
    <a-light type="ambient" color="#CCC"></a-light>
    <a-light type="directional" position="-1 1 2" intensity="0.5"></a-light>
    
    <a-sphere
      id="earth"
      position="0 1.5 -3.2"
      radius="1"
      scale="1 1 1"
      src="eartn_model/world.topo.200409.3x10800x5400.jpg"
      segments-height="64"
      segments-width="128"
      earth-controls
      marker-placer>
    </a-sphere>

    <!-- カメラとコントローラーをリグで囲む -->
    <a-entity id="rig">
      <!-- カメラ -->
      <a-entity id="camera" camera position="0 1.6 0" look-controls></a-entity>
      
      <!-- コントローラー -->
      <a-entity id="left-hand" oculus-touch-controls="hand: left"></a-entity>
      <a-entity id="right-hand" 
                oculus-touch-controls="hand: right"
                laser-controls="hand: right"
                raycaster="objects: .collidable; far: 5;">
      </a-entity>
    </a-entity>

    <!-- 背景色を明るくして見やすくする -->
    <a-sky color="#ECECEC"></a-sky>
  </a-scene>
</body>
</html>
