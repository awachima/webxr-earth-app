<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>WebXR Earth Controls</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <!-- Troika（順序厳守） -->
  <script src="https://cdn.jsdelivr.net/npm/troika-worker-utils@0.43.0/dist/troika-worker-utils.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/troika-three-utils@0.47.2/dist/troika-three-utils.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/troika-three-text@0.47.2/dist/troika-three-text.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-troika-text@0.9.0/dist/aframe-troika-text.min.js"></script>

  <style>html,body{margin:0;height:100%;background:#f4f7fb}</style>
</head>
<body>
<script>
/* ----------------- 共有状態 ----------------- */
window.__panelOpen  = false;
window.__hoveringUI = false;

function refreshAllRaycasters(){
  ['#mouseCursor','#right-hand'].forEach(sel=>{
    const el = document.querySelector(sel);
    const rc = el && el.components && el.components.raycaster;
    if (rc && rc.refreshObjects) rc.refreshObjects();
  });
}

function setupUIHoverWatcher(){
  const cursor = document.querySelector('#mouseCursor');
  if (!cursor) return;
  const setHover = (els)=>window.__hoveringUI=(els||[]).some(el=>el.classList&&el.classList.contains('ui'));
  cursor.addEventListener('raycaster-intersection', e=>setHover(e.detail.els));
  cursor.addEventListener('raycaster-intersection-cleared', ()=>setHover([]));
}

/* ----------------- 地球操作 ----------------- */
AFRAME.registerComponent('earth-controls',{
  schema:{
    rotationSpeed:{default:2.0},
    joystickRotationSpeed:{default:1.0},
    scaleSpeed:{default:0.01},
    mouseRotationSpeed:{default:0.2},
    wheelScaleSpeed:{default:0.0005}
  },
  init(){
    this.minScale=1.0; this.maxScale=3.0;
    this.currentXRotation=0;
    this.keys={}; this.stick={left:{x:0,y:0}, right:{x:0,y:0}};
    this.drag=false; this.prev={x:0,y:0};
    this.cameraEl=document.querySelector('#camera');

    this.el.sceneEl.addEventListener('thumbstickmoved', e=>{
      if (e.target.id==='left-hand')  this.stick.left=e.detail;
      if (e.target.id==='right-hand') this.stick.right=e.detail;
    });
    window.addEventListener('keydown',e=>this.keys[e.key]=true);
    window.addEventListener('keyup',e=>this.keys[e.key]=false);

    this.el.sceneEl.addEventListener('loaded',()=>{
      const cvs=this.el.sceneEl.canvas;
      cvs.addEventListener('mousedown',e=>{
        if (window.__panelOpen) return;
        this.drag=true; this.prev={x:e.clientX,y:e.clientY};
        this.cameraEl && this.cameraEl.setAttribute('look-controls','enabled:false');
      });
      window.addEventListener('mousemove',e=>{
        if (window.__panelOpen||!this.drag) return;
        const dx=e.clientX-this.prev.x, dy=e.clientY-this.prev.y;
        this.el.object3D.rotation.y += dx*(Math.PI/180)*this.data.mouseRotationSpeed;
        this.currentXRotation += dy*this.data.mouseRotationSpeed;
        this.prev={x:e.clientX,y:e.clientY};
      });
      window.addEventListener('mouseup',()=>{
        this.drag=false;
        this.cameraEl && this.cameraEl.setAttribute('look-controls','enabled:true');
      });
      cvs.addEventListener('wheel',e=>{
        if (window.__panelOpen||window.__hoveringUI) return;
        let s=this.el.object3D.scale.x;
        s += e.deltaY * -1 * this.data.wheelScaleSpeed;
        s=Math.max(this.minScale,Math.min(this.maxScale,s));
        this.el.object3D.scale.set(s,s,s);
      },{passive:true});
    });
  },
  tick(){
    if (window.__panelOpen) return;
    const s=this.el.object3D.scale.x;
    const t=(s-1)/(3-1), mul=1-(t*(7/8));

    const ky=(this.keys['ArrowLeft']?-1:0)+(this.keys['ArrowRight']?1:0);
    const kx=(this.keys['ArrowUp']?-1:0)+(this.keys['ArrowDown']?1:0);
    const kz=((this.keys['w']||this.keys['W'])?1:0)+((this.keys['s']||this.keys['S'])?-1:0);

    const ry=(this.stick.right.x||0)*this.data.joystickRotationSpeed*mul || ky*this.data.rotationSpeed*mul;
    const rx=(this.stick.right.y||0)*this.data.joystickRotationSpeed*mul || kx*this.data.rotationSpeed*mul;
    const sc=(this.stick.left.y!==0?-this.stick.left.y:kz)*this.data.scaleSpeed;

    this.el.object3D.rotation.y += ry*(Math.PI/180);
    this.currentXRotation = Math.max(-80,Math.min(80,this.currentXRotation+rx));
    this.el.object3D.rotation.x = this.currentXRotation*(Math.PI/180);

    let ns=s+sc; ns=Math.max(this.minScale,Math.min(this.maxScale,ns));
    this.el.object3D.scale.set(ns,ns,ns);
  }
});

/* ----------------- クラスタ（六角柱＋数字） ----------------- */
AFRAME.registerComponent('hex-marker',{
  schema:{
    count:{type:'number',default:1},
    color:{type:'color',default:'yellow'},
    baseRadius:{type:'number',default:0.0075},
    heightUnit:{type:'number',default:0.0001}
  },
  init(){
    const d=this.data;
    this.height=0.01 + d.count*d.heightUnit;

    // 六角柱（レイキャスト対象）
    const geom=new THREE.CylinderGeometry(d.baseRadius*0.9,d.baseRadius,this.height,6);
    const mat=new THREE.MeshStandardMaterial({color:d.color,flatShading:true});
    const mesh=new THREE.Mesh(geom,mat);
    this.el.setObject3D('mesh',mesh);

    // 数字（TroikaText / 前面固定）
    const label=document.createElement('a-entity');
    label.setAttribute('troika-text',{
      value:String(d.count),
      font:'static/NotoSansJP-Regular.ttf',
      color:'#111111',
      fontSize:d.baseRadius*0.8,
      outlineWidth:0.0006,
      outlineColor:'#ffffff',
      outlineBlur:0.00001,
      depthOffset:-2
    });
    label.setAttribute('position','0 0 0');
    label.addEventListener('object3dset',()=>{
      const obj=label.getObject3D('mesh');
      if (obj && obj.material){ obj.material.depthTest=false; obj.material.needsUpdate=true; obj.renderOrder=20; }
    });
    this.el.appendChild(label);
    this.label=label;

    this.cameraEl=document.querySelector('#camera');
  },
  tick(){
    if (!this.label) return;
    const s=this.el.object3D.scale.y||1;
    const gap=0.0001/s;
    this.label.object3D.position.set(0,this.height/2+gap,0);

    if (this.cameraEl){
      const camPos=this.cameraEl.object3D.getWorldPosition(new THREE.Vector3());
      this.label.object3D.lookAt(camPos);
      this.label.object3D.rotateX(-Math.PI/2);
    }
  }
});

/* ----------------- 位置計算＆配置 ----------------- */
AFRAME.registerComponent('marker-placer',{
  schema:{maxMarkerMultiplier:{default:12}},
  async init(){
    this.all=[]; this.markers=[];
    this.cam=document.querySelector('#camera');
    this.info=document.querySelector('#info-panel');
    this.prevScale=0;

    const url="https://docs.google.com/spreadsheets/d/e/2PACX-1vSOToLaddWpng4D3j-FoN9rHXteriNlykqGJ5VJIUqhvxVKKdrTJ_dfEpgXxXC9hd-YcbfaodERb01x/pub?gid=0&single=true&output=csv";
    try{
      const r=await fetch(url); if(!r.ok) throw new Error('fetch failed');
      const csv=await r.text(); this.all=this.parse(csv);
    }catch(e){ console.error(e); }
    this.updateClusters();
  },
  parse(csv){
    const out=[]; const lines=csv.trim().split('\n');
    const start=lines[0].toLowerCase().includes('title')?1:0;
    for(let i=start;i<lines.length;i++){
      const p=lines[i].split(',');
      if (p.length>=4) out.push({title:p[0].replace(/"/g,''),lat:+p[1],lon:+p[2],url:p[3].replace(/"/g,'')});
    }
    return out;
  },
  _refresh(){ refreshAllRaycasters(); },
  updateClusters(){
    this.markers.forEach(m=>m.parentNode&&m.parentNode.removeChild(m));
    this.markers.length=0; this._refresh();

    const s=this.el.object3D.scale.x;
    const minS=1,maxS=3,minTh=0.2,maxTh=0.0035;
    const t=(s-minS)/(maxS-minS), th=minTh - t*(minTh-maxTh);

    let rest=[...this.all]; const clusters=[];
    while(rest.length){
      const p=rest.shift(), cl=[p], tmp=[];
      for(const q of rest){
        if (this.haversine(p,q)<th) cl.push(q); else tmp.push(q);
      }
      rest=tmp; clusters.push(cl);
    }
    this.place(clusters);
  },
  place(clusters){
    const R=this.el.getAttribute('geometry').radius;
    clusters.forEach(cl=>{
      let lat=0,lon=0; cl.forEach(p=>{lat+=p.lat;lon+=p.lon;}); lat/=cl.length; lon/=cl.length;
      const pos=this.latLon(lat,lon,R);

      const e=document.createElement('a-entity');
      e.setAttribute('position',pos);
      // 法線合わせ
      const y=pos.clone().normalize(), up=new THREE.Vector3(0,1,0);
      const x=new THREE.Vector3().crossVectors(up,y).normalize(); if (!x.length()) x.set(1,0,0);
      const z=new THREE.Vector3().crossVectors(x,y);
      const m=new THREE.Matrix4().makeBasis(x,y,z); e.object3D.quaternion.setFromRotationMatrix(m);

      e.setAttribute('hex-marker',{count:cl.length});
      e.classList.add('collidable');
      e.dataset.locations=JSON.stringify(cl);

      e.addEventListener('mouseenter',()=>{
        if (window.__panelOpen) return;
        const mesh=e.getObject3D('mesh'); if (mesh) mesh.material.color.set('green');
      });
      e.addEventListener('mouseleave',()=>{
        if (window.__panelOpen) return;
        const mesh=e.getObject3D('mesh'); if (mesh) mesh.material.color.set('yellow');
      });
      e.addEventListener('click',()=>{
        if (window.__panelOpen) return;
        const locs=JSON.parse(e.dataset.locations||'[]');
        this.info.setAttribute('info-panel',{locations:locs});
        this.info.setAttribute('visible',true);
        window.__panelOpen=true;
      });

      this.el.appendChild(e);
      this.markers.push(e);
    });
    this._refresh();
  },
  haversine(a,b){
    const r=x=>x*Math.PI/180;
    const dLat=r(b.lat-a.lat), dLon=r(b.lon-a.lon);
    const la1=r(a.lat), la2=r(b.lat);
    const h=Math.sin(dLat/2)**2 + Math.sin(dLon/2)**2 * Math.cos(la1)*Math.cos(la2);
    return 2*Math.atan2(Math.sqrt(h),Math.sqrt(1-h));
  },
  tick(){
    if (!this.markers.length||!this.cam) return;
    const s=this.el.object3D.scale.x;
    if (Math.abs(s-this.prevScale)>0.1){ this.updateClusters(); this.prevScale=s; }

    const camPos=this.cam.object3D.getWorldPosition(new THREE.Vector3());
    const earthPos=this.el.object3D.getWorldPosition(new THREE.Vector3());
    const t=(s-1)/(3-1), mul=this.data.maxMarkerMultiplier - t*(this.data.maxMarkerMultiplier-1);

    for(const e of this.markers){
      e.object3D.scale.set(mul,mul,mul);
      const w=e.object3D.getWorldPosition(new THREE.Vector3());
      const normal=w.clone().sub(earthPos).normalize();
      const camDir=w.clone().sub(camPos).normalize();
      const visible=(normal.dot(camDir)<0);
      e.object3D.visible=visible;
    }
  },
  latLon(lat,lon,R){
    const phi=(90-lat)*(Math.PI/180), th=(lon+180)*(Math.PI/180);
    return new THREE.Vector3(
      -(R*Math.sin(phi)*Math.cos(th)),
      R*Math.cos(phi),
      R*Math.sin(phi)*Math.sin(th)
    );
  }
});

/* ----------------- パネル ----------------- */
AFRAME.registerComponent('info-panel',{
  schema:{
    locations:{type:'array',default:[]},
    cornerRadius:{default:0.06},
    panelWidth:{default:1.2},
    panelHeight:{default:0.9},
    panelColor:{default:'#333'},
    panelOpacity:{default:0.85},
    borderColor:{default:'#fff'},
    fontUrl:{default:'static/NotoSansJP-Regular.ttf'},
    maxTitles:{default:28}
  },
  init(){
    const w=this.data.panelWidth, h=this.data.panelHeight;
    const r=Math.min(this.data.cornerRadius,Math.min(w,h)*0.49);

    const shape=new THREE.Shape();
    const x=-w/2,y=h/2;
    shape.moveTo(x+r,y);
    shape.lineTo(x+w-r,y); shape.quadraticCurveTo(x+w,y,x+w,y-r);
    shape.lineTo(x+w,y-h+r); shape.quadraticCurveTo(x+w,y-h,x+w-r,y-h);
    shape.lineTo(x+r,y-h); shape.quadraticCurveTo(x,y-h,x,y-h+r);
    shape.lineTo(x,y-r); shape.quadraticCurveTo(x,y,x+r,y);

    const g=new THREE.ShapeGeometry(shape,32);
    const m=new THREE.MeshBasicMaterial({color:this.data.panelColor,transparent:true,opacity:this.data.panelOpacity});
    this.panel=new THREE.Mesh(g,m); this.el.setObject3D('panel',this.panel);

    const borderPts=shape.getPoints(128).map(p=>new THREE.Vector3(p.x,p.y,0.001));
    const gl=new THREE.BufferGeometry().setFromPoints(borderPts);
    this.line=new THREE.LineLoop(gl,new THREE.LineBasicMaterial({color:this.data.borderColor}));
    this.el.setObject3D('line',this.line);

    [this.panel,this.line].forEach((obj,i)=>{
      obj.renderOrder=990+i; if (obj.material){obj.material.depthTest=false; obj.material.needsUpdate=true;}
    });

    this.list=document.createElement('a-entity'); this.el.appendChild(this.list);

    const close=document.createElement('a-entity');
    close.setAttribute('position',`${w/2-0.06} ${h/2-0.06} 0.02`);
    close.classList.add('ui');
    const bg=document.createElement('a-circle'); bg.setAttribute('radius',0.04); bg.setAttribute('color','red');
    bg.setAttribute('material','depthTest:false; transparent:true'); close.appendChild(bg);
    const bar=(rot)=>{const p=document.createElement('a-plane'); p.setAttribute('width',0.055); p.setAttribute('height',0.007);
      p.setAttribute('rotation',`0 0 ${rot}`); p.setAttribute('color','#fff'); p.setAttribute('position','0 0 0.001');
      p.setAttribute('material','depthTest:false; transparent:true'); close.appendChild(p);};
    bar(45); bar(-45);
    this.el.appendChild(close);
    close.addEventListener('click',()=>{ this.el.setAttribute('visible',false); window.__panelOpen=false; });

    this.top=0;
    this.onWheel=(e)=>{
      if (!window.__panelOpen) return;
      const d=Math.sign(e.deltaY);
      const max=Math.max(0,(this.locations?.length||0)-this.data.maxTitles);
      this.top=Math.max(0,Math.min(max,this.top+d));
      this.render();
    };
    this.el.sceneEl.addEventListener('loaded',()=>{
      this.el.sceneEl.canvas.addEventListener('wheel',this.onWheel,{passive:true});
    });

    this.locations=[];
  },
  update(){ this.locations=this.data.locations||[]; this.top=0; this.render(); },
  remove(){
    const cvs=this.el.sceneEl && this.el.sceneEl.canvas;
    if (cvs) cvs.removeEventListener('wheel',this.onWheel);
  },
  render(){
    while(this.list.firstChild) this.list.removeChild(this.list.firstChild);
    const w=this.data.panelWidth, h=this.data.panelHeight;
    const locs=(this.locations||[]).slice(this.top,this.top+this.data.maxTitles);
    locs.forEach((loc,i)=>{
      const t=document.createElement('a-entity');
      t.setAttribute('troika-text',{
        value:loc.title, font:this.data.fontUrl, fontSize:0.06, color:'#fff',
        anchor:'left', outlineWidth:0.0006, outlineColor:'#000', outlineBlur:0.00001, depthOffset:-2
      });
      t.setAttribute('position',`-${w/2-0.1} ${h/2-0.15-(i*0.065)} 0.02`);
      t.addEventListener('object3dset',()=>{
        const mesh=t.getObject3D('mesh'); if (mesh){ mesh.renderOrder=1000; mesh.material.depthTest=false; mesh.material.needsUpdate=true; }
      });
      this.list.appendChild(t);
    });
    refreshAllRaycasters();
  }
});

/* ----------------- VR 可視/不可視（tracked-controls-webxr は使わない） ----------------- */
function setupVRHandVisibility(){
  const scene=document.querySelector('a-scene');
  const L=document.getElementById('left-hand');
  const R=document.getElementById('right-hand');
  scene.addEventListener('enter-vr',()=>{ L.setAttribute('visible',true); R.setAttribute('visible',true); });
  scene.addEventListener('exit-vr', ()=>{ L.setAttribute('visible',false); R.setAttribute('visible',false); });
}
window.addEventListener('DOMContentLoaded',()=>{ setupUIHoverWatcher(); setupVRHandVisibility(); });
</script>

<a-scene
  renderer="highRefreshRate:true"
  webxr="requiredFeatures: local-floor; optionalFeatures: bounded-floor,dom-overlay; overlayElement:#hud"
  vr-mode-ui="enabled: true">

  <a-light type="ambient" color="#CCC"></a-light>
  <a-light type="directional" position="-1 1 2" intensity="0.6"></a-light>

  <a-sphere id="earth"
            position="0 1.5 -3.2"
            radius="1"
            src="eartn_model/world.topo.200409.3x10800x5400.jpg"
            segments-height="64" segments-width="128"
            earth-controls marker-placer>
  </a-sphere>

  <a-entity id="rig">
    <a-entity id="camera" camera position="0 1.6 0" look-controls>
      <a-entity id="mouseCursor"
        cursor="rayOrigin: mouse; fuse: false"
        raycaster="objects: .collidable, .ui; useWorldCoordinates: true; far: 30; interval: 0">
      </a-entity>
      <a-entity id="info-panel" class="ui" info-panel visible="false" position="0 0 -0.9"></a-entity>
    </a-entity>

    <!-- VR コントローラ：tracked-controls-webxr は付けない -->
    <a-entity id="left-hand"
      oculus-touch-controls="hand: left; model: true"
      visible="false"></a-entity>

    <a-entity id="right-hand"
      oculus-touch-controls="hand: right; model: true"
      laser-controls="hand: right"
      cursor="rayOrigin: entity; fuse: false"
      raycaster="objects: .collidable, .ui; useWorldCoordinates: true; far: 30; interval: 0; showLine: true"
      visible="false"></a-entity>
  </a-entity>

  <a-sky color="#ECECEC"></a-sky>
  <div id="hud" style="position:absolute;left:0;top:0;"></div>
</a-scene>
</body>
</html>
