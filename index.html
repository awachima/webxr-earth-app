<!DOCTYPE html>
<html>
<head>
  <title>WebXR Earth Controls (Optimized)</title>
  <!-- 正しく動作したA-Frameのライブラリ -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- ★★★ インスタンス化のためのライブラリを追加 ★★★ -->
  <script src="https://cdn.jsdelivr.net/gh/diarmidmackenzie/aframe-instanced-mesh-component/dist/aframe-instanced-mesh-component.min.js"></script>
</head>
<body>
  <!-- JavaScriptで独自の操作機能を定義 -->
  <script>
    // 'earth-controls'という名前の新しい部品（コンポーネント）を定義します
    AFRAME.registerComponent('earth-controls', {
      // 初期設定
      schema: {
        rotationSpeed: { type: 'number', default: 2.0 }, // 回転の速さ
        scaleSpeed: { type: 'number', default: 0.01 }   // 拡大・縮小の速さ
      },

      // コンポーネントが初期化されるときに一度だけ呼ばれる関数
      init: function () {
        // 変数の準備
        this.minScale = 1.0;
        this.maxScale = 3.0;
        this.currentXRotation = 0;
        this.keys = {}; // 押されているキーの状態
        this.stickInput = { left: {x: 0, y: 0}, right: {x: 0, y: 0} }; // スティックの入力状態

        // --- イベントリスナーの登録 ---
        this.onStickMoved = this.onStickMoved.bind(this);
        this.el.sceneEl.addEventListener('thumbstickmoved', this.onStickMoved);

        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        window.addEventListener('keydown', this.onKeyDown);
        window.addEventListener('keyup', this.onKeyUp);
      },
      
      onKeyDown: function (evt) { this.keys[evt.key] = true; },
      onKeyUp: function (evt) { this.keys[evt.key] = false; },

      // VRコントローラーのスティックが動いた時の処理
      onStickMoved: function (evt) {
        if (evt.target.id === 'left-hand') {
          this.stickInput.left = evt.detail;
        } else if (evt.target.id === 'right-hand') {
          this.stickInput.right = evt.detail;
        }
      },

      // 毎フレーム呼ばれる更新処理 (tick)
      tick: function () {
        // --- 入力値の取得 ---
        const rotY_keyboard = (this.keys['ArrowLeft'] ? -1 : 0) + (this.keys['ArrowRight'] ? 1 : 0);
        const rotX_keyboard = (this.keys['ArrowUp'] ? -1 : 0) + (this.keys['ArrowDown'] ? 1 : 0);
        const scale_keyboard = (this.keys['w'] || this.keys['W'] ? 1 : 0) + (this.keys['s'] || this.keys['S'] ? -1 : 0);

        // スケールに基づいて回転速度の倍率を計算
        const currentScaleValue = this.el.object3D.scale.x;
        const t = (currentScaleValue - this.minScale) / (this.maxScale - this.minScale);
        const rotationMultiplier = 1 - (t * (7 / 8));

        // --- 値の計算 ---
        // 回転
        const finalRotY = (this.stickInput.right.x !== 0 ? this.stickInput.right.x : rotY_keyboard) * this.data.rotationSpeed * rotationMultiplier;
        const finalRotX = (this.stickInput.right.y !== 0 ? this.stickInput.right.y : rotX_keyboard) * this.data.rotationSpeed * rotationMultiplier;
        
        // 拡縮
        const finalScale = (this.stickInput.left.y !== 0 ? -this.stickInput.left.y : scale_keyboard) * this.data.scaleSpeed;

        // --- 計算結果の適用 ---
        this.el.object3D.rotation.y += finalRotY * (Math.PI / 180);
        this.currentXRotation -= finalRotX;
        this.currentXRotation = Math.max(-80, Math.min(80, this.currentXRotation));
        this.el.object3D.rotation.x = this.currentXRotation * (Math.PI / 180);

        let newScale = currentScaleValue + finalScale;
        newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
        this.el.object3D.scale.set(newScale, newScale, newScale);
      },

      remove: function() {
        this.el.sceneEl.removeEventListener('thumbstickmoved', this.onStickMoved);
        window.removeEventListener('keydown', this.onKeyDown);
        window.removeEventListener('keyup', this.onKeyUp);
      }
    });

    // マーカーを配置するためのコンポーネント
    AFRAME.registerComponent('marker-placer', {
      schema: {
        maxMarkerMultiplier: {type: 'number', default: 12}
      },
      init: function() {
        this.instancedMesh = this.el.querySelector('[instanced-mesh]').components['instanced-mesh'];
        this.previousEarthScale = 0; // 前フレームのスケールを保存
        this.markersData = []; // マーカーの位置と向きを保存

        // 2000個のランダムなサンプルデータを生成
        const locations = [];
        for (let i = 0; i < 2000; i++) {
            locations.push({
                lat: Math.random() * 180 - 90,
                lon: Math.random() * 360 - 180,
                count: Math.floor(Math.random() * 50) + 1
            });
        }

        const earthRadius = this.el.getAttribute('geometry').radius;

        locations.forEach(loc => {
          const pos = this.latLonTo3D(loc.lat, loc.lon, earthRadius);
          const quat = this.getLookAtQuaternion(pos);
          this.markersData.push({position: pos, quaternion: quat});
        });

        // インスタンスを描画
        this.instancedMesh.updateInstancedMesh(this.markersData);
      },

      tick: function() {
        const earthScale = this.el.object3D.scale.x;
        // ★★★ 地球のスケールが変化した時だけ計算を実行 ★★★
        if (earthScale === this.previousEarthScale) return;

        const t = (earthScale - 1) / (3 - 1); 
        const markerScale = this.data.maxMarkerMultiplier - t * (this.data.maxMarkerMultiplier - 1);
        
        // 全てのマーカーのスケールを更新
        for(let i = 0; i < this.markersData.length; i++) {
            this.markersData[i].scale = {x: markerScale, y: markerScale, z: markerScale};
        }
        this.instancedMesh.updateInstancedMesh(this.markersData);

        this.previousEarthScale = earthScale; // スケールを保存
      },

      getLookAtQuaternion: function(pos) {
          const yAxis = pos.clone().normalize();
          const worldUp = new THREE.Vector3(0, 1, 0);
          const xAxis = new THREE.Vector3().crossVectors(worldUp, yAxis).normalize();
          if (xAxis.length() === 0) {
            xAxis.set(1, 0, 0);
          }
          const zAxis = new THREE.Vector3().crossVectors(xAxis, yAxis);
          const rotationMatrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
          return new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
      },

      latLonTo3D: function(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        return new THREE.Vector3(x, y, z);
      }
    });

  </script>

  <!-- renderer="antialias: true" を追加して、描画を滑らかにする -->
  <a-scene renderer="antialias: true">
    
    <!-- ★★★ インスタンス化するマーカーの「原型」を定義 (非表示) ★★★ -->
    <a-assets>
        <a-entity id="marker-shape" visible="false">
            <a-cylinder radius-top="0.00675" radius-bottom="0.0075" height="0.01" segments-radial="6" material="color: yellow; flatShading: true"></a-cylinder>
        </a-entity>
    </a-assets>

    <!-- シーンに照明を追加 -->
    <a-light type="ambient" color="#CCC"></a-light>
    <a-light type="directional" position="-1 1 2" intensity="0.5"></a-light>
    
    <a-sphere
      id="earth"
      position="0 1.5 -3.2"
      radius="1"
      scale="1 1 1"
      src="eartn_model/world.topo.200409.3x10800x5400.jpg"
      segments-height="50"
      segments-width="100"
      earth-controls
      marker-placer>
      <!-- ★★★ ここで2000個のマーカーを一度に描画 ★★★ -->
      <a-entity instanced-mesh="#marker-shape"></a-entity>
    </a-sphere>

    <!-- カメラとコントローラーをリグで囲む -->
    <a-entity id="rig">
      <!-- カメラ -->
      <a-entity id="camera" camera position="0 1.6 0" look-controls></a-entity>
      
      <!-- コントローラー -->
      <a-entity id="left-hand" oculus-touch-controls="hand: left"></a-entity>
      <a-entity id="right-hand" 
                oculus-touch-controls="hand: right"
                laser-controls="hand: right"
                raycaster="objects: .collidable; far: 5;">
      </a-entity>
    </a-entity>

    <!-- 背景色を明るくして見やすくする -->
    <a-sky color="#ECECEC"></a-sky>
  </a-scene>
</body>
</html>
