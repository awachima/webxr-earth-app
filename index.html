<!DOCTYPE html>
<html>
<head>
  <title>WebXR Earth Controls</title>
  <!-- ★★★ 正しく動作するURLに修正 ★★★ -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- データ用のscriptタグは不要になったため削除 -->
</head>
<body>
  <!-- JavaScriptで独自の操作機能を定義 -->
  <script>
    // 'earth-controls'という名前の新しい部品（コンポーネント）を定義します
    AFRAME.registerComponent('earth-controls', {
      // 初期設定
      schema: {
        rotationSpeed: { type: 'number', default: 2.0 }, // キーボードの回転速度
        // ★★★ ジョイスティック専用の回転速度を追加 ★★★
        joystickRotationSpeed: { type: 'number', default: 1.0 }, // ジョイスティックの回転速度
        scaleSpeed: { type: 'number', default: 0.01 },   // 拡大・縮小の速さ
        mouseRotationSpeed: { type: 'number', default: 0.2 }, // マウス回転の速さ
        wheelScaleSpeed: { type: 'number', default: 0.0005 } // ホイール拡縮の速さ
      },

      // コンポーネントが初期化されるときに一度だけ呼ばれる関数
      init: function () {
        // 変数の準備
        this.minScale = 1.0;
        this.maxScale = 3.0;
        this.currentXRotation = 0;
        this.keys = {}; // 押されているキーの状態
        this.stickInput = { left: {x: 0, y: 0}, right: {x: 0, y: 0} }; // スティックの入力状態
        this.isDragging = false;
        this.previousMousePosition = { x: 0, y: 0 };
        this.cameraEl = document.querySelector('#camera');


        // --- イベントリスナーの登録 ---
        this.onStickMoved = this.onStickMoved.bind(this);
        this.el.sceneEl.addEventListener('thumbstickmoved', this.onStickMoved);

        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        window.addEventListener('keydown', this.onKeyDown);
        window.addEventListener('keyup', this.onKeyUp);

        // マウス操作用のイベントリスナーを追加
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onWheel = this.onWheel.bind(this);
        this.el.sceneEl.canvas.addEventListener('mousedown', this.onMouseDown);
        window.addEventListener('mousemove', this.onMouseMove);
        window.addEventListener('mouseup', this.onMouseUp);
        window.addEventListener('wheel', this.onWheel);
      },
      
      onKeyDown: function (evt) { this.keys[evt.key] = true; },
      onKeyUp: function (evt) { this.keys[evt.key] = false; },

      // マウス操作用の関数
      onMouseDown: function(evt) {
        this.isDragging = true;
        this.previousMousePosition = { x: evt.clientX, y: evt.clientY };
        if (this.cameraEl) {
            this.cameraEl.setAttribute('look-controls', 'enabled', false);
        }
      },
      onMouseMove: function(evt) {
        if (!this.isDragging) return;
        const deltaX = evt.clientX - this.previousMousePosition.x;
        const deltaY = evt.clientY - this.previousMousePosition.y;

        this.el.object3D.rotation.y += deltaX * (Math.PI / 180) * this.data.mouseRotationSpeed;
        this.currentXRotation -= deltaY * this.data.mouseRotationSpeed;

        this.previousMousePosition = { x: evt.clientX, y: evt.clientY };
      },
      onMouseUp: function() {
        this.isDragging = false;
        if (this.cameraEl) {
            this.cameraEl.setAttribute('look-controls', 'enabled', true);
        }
      },
      onWheel: function(evt) {
        let currentScale = this.el.object3D.scale.x;
        const scaleAmount = evt.deltaY * -1 * this.data.wheelScaleSpeed;
        currentScale += scaleAmount;
        currentScale = Math.max(this.minScale, Math.min(this.maxScale, currentScale));
        this.el.object3D.scale.set(currentScale, currentScale, currentScale);
      },


      // VRコントローラーのスティックが動いた時の処理
      onStickMoved: function (evt) {
        if (evt.target.id === 'left-hand') {
          this.stickInput.left = evt.detail;
        } else if (evt.target.id === 'right-hand') {
          this.stickInput.right = evt.detail;
        }
      },

      // 毎フレーム呼ばれる更新処理 (tick)
      tick: function () {
        // --- 入力値の取得 ---
        const rotY_keyboard = (this.keys['ArrowLeft'] ? -1 : 0) + (this.keys['ArrowRight'] ? 1 : 0);
        const rotX_keyboard = (this.keys['ArrowUp'] ? -1 : 0) + (this.keys['ArrowDown'] ? 1 : 0);
        const scale_keyboard = (this.keys['w'] || this.keys['W'] ? 1 : 0) + (this.keys['s'] || this.keys['S'] ? -1 : 0);

        // スケールに基づいて回転速度の倍率を計算
        const currentScaleValue = this.el.object3D.scale.x;
        const t = (currentScaleValue - this.minScale) / (this.maxScale - this.minScale);
        const rotationMultiplier = 1 - (t * (7 / 8));

        // --- 値の計算 ---
        // ★★★ キーボードとジョイスティックの回転を分離 ★★★
        const rotY_joystick = this.stickInput.right.x * this.data.joystickRotationSpeed * rotationMultiplier;
        const rotX_joystick = this.stickInput.right.y * this.data.joystickRotationSpeed * rotationMultiplier;
        
        const rotY_keyboard_final = rotY_keyboard * this.data.rotationSpeed * rotationMultiplier;
        const rotX_keyboard_final = rotX_keyboard * this.data.rotationSpeed * rotationMultiplier;

        const finalRotY = rotY_joystick !== 0 ? rotY_joystick : rotY_keyboard_final;
        const finalRotX = rotX_joystick !== 0 ? rotX_joystick : rotX_keyboard_final;
        
        // 拡縮
        const finalScale = (this.stickInput.left.y !== 0 ? -this.stickInput.left.y : scale_keyboard) * this.data.scaleSpeed;

        // --- 計算結果の適用 ---
        this.el.object3D.rotation.y += finalRotY * (Math.PI / 180);
        this.currentXRotation -= finalRotX;
        this.currentXRotation = Math.max(-80, Math.min(80, this.currentXRotation));
        this.el.object3D.rotation.x = this.currentXRotation * (Math.PI / 180);

        let newScale = currentScaleValue + finalScale;
        newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
        this.el.object3D.scale.set(newScale, newScale, newScale);
      },

      remove: function() {
        this.el.sceneEl.removeEventListener('thumbstickmoved', this.onStickMoved);
        window.removeEventListener('keydown', this.onKeyDown);
        window.removeEventListener('keyup', this.onKeyUp);
        this.el.sceneEl.canvas.removeEventListener('mousedown', this.onMouseDown);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('wheel', this.onWheel);
      }
    });

    // 六角柱マーカーを生成する新しいコンポーネント
    AFRAME.registerComponent('hex-marker', {
        schema: {
            count: {type: 'number', default: 1},
            color: {type: 'color', default: 'yellow'},
            baseRadius: {type: 'number', default: 0.0075},
            heightUnit: {type: 'number', default: 0.0005}
        },
        init: function() {
            const data = this.data;
            this.height = 0.01 + (data.count * data.heightUnit);
            
            const geometry = new THREE.CylinderGeometry(data.baseRadius * 0.9, data.baseRadius, this.height, 6);
            const material = new THREE.MeshStandardMaterial({color: data.color, flatShading: true});
            const mesh = new THREE.Mesh(geometry, material);
            this.el.setObject3D('mesh', mesh);

            const textEntity = document.createElement('a-text');
            textEntity.setAttribute('value', data.count);
            textEntity.setAttribute('rotation', {x: -90, y: 0, z: 0});
            textEntity.setAttribute('align', 'center');
            textEntity.setAttribute('color', 'black');
            textEntity.setAttribute('width', 0.1);
            
            this.el.appendChild(textEntity);
            this.el.textEl = textEntity;
        },
        tick: function() {
            if (!this.el.textEl) return;

            const parentScale = this.el.object3D.scale.y;
            if (parentScale === 0) return;

            const desiredGap = 0.0001;
            const adjustedGap = desiredGap / parentScale;

            this.el.textEl.setAttribute('position', {x: 0, y: this.height / 2 + adjustedGap, z: 0});
        }
    });


    // マーカーを配置するためのコンポーネント
    AFRAME.registerComponent('marker-placer', {
      schema: {
        maxMarkerMultiplier: {type: 'number', default: 12}
      },
      init: async function() {
        this.allLocations = []; // 全ての地点データを保存
        this.currentMarkers = []; // 現在表示中のマーカーを保存
        this.cameraEl = document.querySelector('#camera');
        this.cameraPos = new THREE.Vector3();
        this.markerPos = new THREE.Vector3();
        this.earthPos = new THREE.Vector3();
        this.previousEarthScale = 0;

        // Google Sheetsからデータを読み込む
        const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSOToLaddWpng4D3j-FoN9rHXteriNlykqGJ5VJIUqhvxVKKdrTJ_dfEpgXxXC9hd-YcbfaodERb01x/pub?gid=0&single=true&output=csv";
        try {
            const response = await fetch(sheetUrl);
            if (!response.ok) {
                console.error("Google Sheetsからのデータ読み込みに失敗しました。");
            } else {
                const csvText = await response.text();
                this.allLocations = this.parseCsv(csvText);
            }
        } catch (error) {
            console.error("データの取得または解析中にエラーが発生しました:", error);
        }

        // 最初のクラスター更新
        this.updateClusters();
      },

      // CSVデータを解析する関数
      parseCsv: function(csvText) {
        const locations = [];
        const lines = csvText.trim().split('\n');
        const startIndex = lines[0].toLowerCase().includes('title') ? 1 : 0;

        for (let i = startIndex; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length >= 4) {
                locations.push({
                    title: parts[0].replace(/"/g, ''),
                    lat: parseFloat(parts[1]),
                    lon: parseFloat(parts[2]),
                    url: parts[3].replace(/"/g, '')
                });
            }
        }
        return locations;
      },

      // クラスターを更新するメインの関数
      updateClusters: function() {
        // 既存のマーカーをすべて削除
        this.currentMarkers.forEach(marker => marker.parentNode.removeChild(marker));
        this.currentMarkers = [];

        const earthScale = this.el.object3D.scale.x;
        // ★★★ ご指定の値に修正 ★★★
        const minScale = 1.0;
        const maxScale = 3.0;
        const minThreshold = 0.2; // スケールが1倍の時の範囲
        const maxThreshold = 0.0025; // スケールが3倍の時の範囲

        const t = (earthScale - minScale) / (maxScale - minScale);
        const clusterThreshold = minThreshold - t * (minThreshold - maxThreshold);
        
        let unclustered = [...this.allLocations];
        const clusters = [];

        while (unclustered.length > 0) {
            const currentPoint = unclustered.shift();
            const cluster = [currentPoint];
            const remainingPoints = [];

            for (const otherPoint of unclustered) {
                const dist = this.haversineDistance(currentPoint, otherPoint);
                if (dist < clusterThreshold) {
                    cluster.push(otherPoint);
                } else {
                    remainingPoints.push(otherPoint);
                }
            }
            unclustered = remainingPoints;
            clusters.push(cluster);
        }

        // クラスターをマーカーとして配置
        this.placeMarkersFromClusters(clusters);
      },

      // クラスターからマーカーを生成して配置する関数
      placeMarkersFromClusters: function(clusters) {
        const earthRadius = this.el.getAttribute('geometry').radius;

        clusters.forEach(cluster => {
            let avgLat = 0, avgLon = 0;
            cluster.forEach(point => {
                avgLat += point.lat;
                avgLon += point.lon;
            });
            avgLat /= cluster.length;
            avgLon /= cluster.length;

            const pos = this.latLonTo3D(avgLat, avgLon, earthRadius);
            const marker = document.createElement('a-entity');
            marker.setAttribute('position', pos);

            const yAxis = pos.clone().normalize();
            const worldUp = new THREE.Vector3(0, 1, 0);
            const xAxis = new THREE.Vector3().crossVectors(worldUp, yAxis).normalize();
            if (xAxis.length() === 0) {
              xAxis.set(1, 0, 0);
            }
            const zAxis = new THREE.Vector3().crossVectors(xAxis, yAxis);
            const rotationMatrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
            marker.object3D.quaternion.setFromRotationMatrix(rotationMatrix);

            marker.setAttribute('hex-marker', {count: cluster.length});
            marker.classList.add('collidable');
            marker.dataset.locations = JSON.stringify(cluster); // データをJSON文字列として保存

            marker.addEventListener('click', this.onMarkerClick);
            marker.addEventListener('mouseenter', this.onMarkerEnter);
            marker.addEventListener('mouseleave', this.onMarkerLeave);
            
            this.el.appendChild(marker);
            this.currentMarkers.push(marker);
        });
      },

      // 2点間の球面距離を計算する関数
      haversineDistance: function(coords1, coords2) {
        function toRad(x) { return x * Math.PI / 180; }
        const R = 1; // 地球の半径を1とする
        const dLat = toRad(coords2.lat - coords1.lat);
        const dLon = toRad(coords2.lon - coords1.lon);
        const lat1 = toRad(coords1.lat);
        const lat2 = toRad(coords2.lat);

        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2); 
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); 
        return R * c;
      },


      // マーカーのスケールと表示/非表示を毎フレーム更新するtick関数
      tick: function() {
        if (this.currentMarkers.length === 0 || !this.cameraEl) return;

        const earthScale = this.el.object3D.scale.x;
        // スケールが大きく変化した場合のみクラスターを再計算
        if (Math.abs(earthScale - this.previousEarthScale) > 0.1) {
            this.updateClusters();
            this.previousEarthScale = earthScale;
        }

        this.el.object3D.getWorldPosition(this.earthPos);
        this.cameraEl.object3D.getWorldPosition(this.cameraPos);

        const t = (earthScale - 1) / (3 - 1); 
        const markerScale = this.data.maxMarkerMultiplier - t * (this.data.maxMarkerMultiplier - 1);

        for (const marker of this.currentMarkers) {
            marker.object3D.scale.set(markerScale, markerScale, markerScale);
            marker.object3D.getWorldPosition(this.markerPos);
            const markerNormal = this.markerPos.clone().sub(this.earthPos).normalize();
            const cameraToMarkerForOcclusion = this.markerPos.clone().sub(this.cameraPos).normalize();
            const dotProduct = markerNormal.dot(cameraToMarkerForOcclusion);
            const isVisible = (dotProduct < 0);
            marker.object3D.visible = isVisible;
            if (marker.textEl) {
                marker.textEl.object3D.visible = isVisible;
            }
        }
      },

      onMarkerClick: function(evt) {
        const locations = JSON.parse(evt.target.dataset.locations);
        console.log("Clicked cluster with", locations.length, "locations:");
        locations.forEach(loc => console.log("-", loc.title));
      },
      onMarkerEnter: function(evt) {
        const mesh = evt.target.getObject3D('mesh');
        if (mesh) {
            mesh.material.color.set('green');
        }
      },
      onMarkerLeave: function(evt) {
        const mesh = evt.target.getObject3D('mesh');
        if (mesh) {
            mesh.material.color.set('yellow');
        }
      },

      // 緯度経度を3D座標に変換するヘルパー関数
      latLonTo3D: function(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);

        return new THREE.Vector3(x, y, z);
      }
    });

  </script>

  <!-- renderer="antialias: true" を追加して、描画を滑らかにする -->
  <a-scene renderer="antialias: true">
    <!-- シーンに照明を追加 -->
    <a-light type="ambient" color="#CCC"></a-light>
    <a-light type="directional" position="-1 1 2" intensity="0.5"></a-light>
    
    <a-sphere
      id="earth"
      position="0 1.5 -3.2"
      radius="1"
      scale="1 1 1"
      src="eartn_model/world.topo.200409.3x10800x5400.jpg"
      segments-height="64"
      segments-width="128"
      earth-controls
      marker-placer>
    </a-sphere>

    <!-- カメラとコントローラーをリグで囲む -->
    <a-entity id="rig">
      <!-- カメラ -->
      <a-entity id="camera" camera position="0 1.6 0" look-controls>
        <!-- PC操作用のカーソルを追加 -->
        <a-entity cursor="rayOrigin: mouse" raycaster="objects: .collidable; far: 10;"></a-entity>
      </a-entity>
      
      <!-- コントローラー -->
      <a-entity id="left-hand" oculus-touch-controls="hand: left"></a-entity>
      <a-entity id="right-hand" 
                oculus-touch-controls="hand: right"
                laser-controls="hand: right"
                raycaster="objects: .collidable; far: 5;">
      </a-entity>
    </a-entity>

    <!-- 背景色を明るくして見やすくする -->
    <a-sky color="#ECECEC"></a-sky>
  </a-scene>
</body>
</html>
